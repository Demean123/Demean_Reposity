'************************ Palletiz Library *****************************************************************************
'
' File:  NEWPLT.LIB
' Purpose:  This library holds Horizontal Palletizing and Vertical Palletizing data and functions
' Version:  1.0.0.1
' Author:  Demean
'
' History:  18.Sep.2018    V1.0.0.0   - Demean -  Created
'***********************************************************************************************************************

'***********************************************************************************************************************
' Type Name: NewPalletize
' Description: 水平码垛结构体定义
' Called From:  teach pendant
' Author: Demean
' Input Parameters: None
' Output Parameters: None
' Return Value: 
' Algorithm: 
' Global Variables Used: RBT_TABLE
' Revisions:
'***********************************************************************************************************************

type NewPalletize
  glStartPoint[5] as generic location                              '码垛起始点
  glPartPoint[5] as generic location                               '码垛参与点
  glTermPoint[5] as generic location                               '码垛终止点 
  glSinRefPoint as generic location                                '单组路径参考点
  glSinApproachPoint as generic location                           '单组路径趋近点
  glSinBackPoint as generic location                               '单组路径回退点 
  glDouRefPoint as generic location                                '双组路径参考点
  glDouApproachPoint[2] as generic location                        '双组路径趋近点
  glDouBackPoint[2] as generic location                            '双组路径回退点
  glLmJumpRefPoint as generic location                             '龙门跳参考点
  glLmJumpTransPoint as generic location                           '龙门跳过渡点，码垛时看成回退点，拆垛时看成趋近点
  glCalibratedFrame[5] as generic location                         '标定的工件坐标系
  glOriginalBase as generic location                               '机器人运动之前的基坐标系
  glOriginalTool as generic location                               '机器人运动之前的工具坐标系
  glOriginalworkpiece as generic location                          '机器人运动之前的工件坐标系
  glOriginalMachineTable as generic location                       '机器人运动之前的工作台坐标系  
  lAllRowCount as long                                             '码垛的总排数
  lAllWorkpieceCnt as long                                         '每个通道单排的总工件数
  lCurrPalletNum as long                                           '当前已经码垛工件数
  lCurrDepalletNum as long                                         '当前已经拆垛工件数
  lLiftHeight as long                                              '龙门跳的高度值,用于设定6轴机器人 
  lStackType as long                                               '1-表示码垛，2-表示拆垛
  lHorPltMotFlag as long                                           '水平码垛运动方式标志位，1-单组路径，2-双组路径，3-龙门跳转
end type

'***********************************************************************************************************************
' Type Name: NewVerPalletize
' Description: 垂直码垛结构体定义
' Called From:  teach pendant
' Author: Demean
' Input Parameters: None
' Output Parameters: None
' Return Value: 
' Algorithm: 
' Global Variables Used: RBT_TABLE
' Revisions:
'***********************************************************************************************************************
type NewVerPalletize
  glVerRefPointOne as generic location                              '垂直码垛参考点1
  glVerRefPointTwo as generic location                              '垂直码垛参考点2
  glVerRefPointThree as generic location                            '垂直码垛参考点3
  
  glVerSinRefPoint as generic location                              '垂直码垛单组路径参考点
  glVerSinApproachPoint as generic location                         '垂直码垛单组路径趋近点
  glVerSinBackPoint as generic location                             '垂直码垛单组路径回退点 

  glVerDouRefPoint as generic location                              '垂直码垛双组路径参考点  
  glVerDouApproachPoint[2] as generic location                      '垂直码垛双组路径趋近点
  glVerDouBackPoint[2] as generic location                          '垂直码垛双组路径回退点

  glVerCalibratedFrame as generic location                          '垂直码垛工件坐标系标定数据保存
  glVerOriginalBase as generic location                             '机器人运动之前的基坐标系
  glVerOriginalTool as generic location                             '机器人运动之前的工具坐标系
  glVerOriginalWorkpiece as generic location                        '机器人运动之前的工件坐标系
  glVerOriginalMachineTable as generic location                     '机器人运动之前的工作台坐标系  
  
  llengthofWorkpiece   as double                                    '垂直码垛每个工件的长度
  lWidthofWorkpiece   as double                                     '垂直码垛每个工件的宽度
  lHeightofWorkpiece as double                                      '垂直码垛每个工件的高度
  lHeightofClapBoard as double                                      '垂直码垛每层隔板的厚度
  lRowSpacing as double                                             '垂直码垛每个工件的行间距
  lColumnSpacing as double                                          '垂直码垛每个工件的列间距
  lVerNumofPlies as long                                            '垂直码垛每个通道的总层数
  lVerCurrPalletNum as long                                         '垂直码垛当前已经码垛工件数
  lVerCurrDepalletNum as long                                       '垂直码垛当前已经拆垛工件数   
  lVerStackType as long                                             '1-表示码垛，2-表示拆垛
  lVerToolFrameNum as long                                          '垂直码垛保存工具坐标系编号
  lVerPltMotFlag as long                                            '垂直码垛运动方式标志位，1-单组路径，2-双组路径
end type

'*****************************分割线***********************************************************************************
'*****************************定义变量*********************************************************************************
'**********************************************************************************************************************
common shared NewPltPackage as string = "HS_MC_V1.0.3.190104"    '码垛工艺包版本号
common shared TotalPltArray[6] as NewPalletize                   '声明总的码垛结构体数组变量，数量为5组，索引从1开始，上限是5
common shared TotalVerPltArray[6] as NewVerPalletize             '声明垂直码垛结构体数组变量，数量为5组，索引从1开始，上限是5
common shared lVerPltAllWPCount[6] as long                       '垂直码垛总工件数
common shared lHorChannelNum as long                             '用于保存水平码垛通道编号
common shared lVerChannelNum as long                             '用于保存水平码垛通道编号

common shared lSetWorkpieceFlag as long =False                   '还原为默认workpiece程序开始标志位

dim shared glVerPltCalcLoc as generic location                   '用于垂直码垛计算工件码垛点，此变量用于保存中间计算结果
dim shared glCalcLoc as generic location                         '用于计算工件码垛点，此变量用于保存中间计算结果

'*****************************水平码垛计算专用*************************************************************************
dim shared glActualPltPoint as generic location                  '经过计算后每个工件的实际码垛点
dim shared glSCompTempLoc as generic location                    '用于单组路径比较点位的临时变量
dim shared glTranTempLoc as generic location                     '用于趋近点运动、回退点运动过渡用的变量
dim shared glDCompTempLoc[2] as generic location                 '用于双组路径比较点位的临时变量
dim shared glOneLoc as generic location                          '用于计算实际的趋近点、回退点的点位变量1
dim shared glTwoLoc as generic location                          '用于计算实际的趋近点、回退点的点位变量2
dim shared glThreeLoc as generic location                        '用于计算实际的趋近点、回退点的点位变量3
dim shared glDeltaVal as generic location                        '△值，用于求解点位的位姿变换
dim shared glInverPT as generic location                         '点位Inverse求逆
dim shared glSinActualAppPoint as generic location               '单组路径实际的趋近点
dim shared glSinActualBackPoint as generic location              '单组路径实际的回退点
dim shared glDouActualAppPoint[2] as generic location            '双组路径实际的趋近点
dim shared glDouActualBackPoint[2] as generic location           '双组路径实际的回退点

dim shared glLMJumpTopPoint  as generic location                 '龙门跳运动码垛上方点
dim shared lZmaxHeight as double                                 '龙门跳的高度值，用于设置4轴机器人
dim shared glLMJumpActualTransPoint as generic location          '龙门跳实际的过渡点，码垛为实际的回退点，拆垛为实际的趋近点

dim shared glCopyAndPasteAr[50] as generic location              '通道数据拷贝中间变量gl数组
dim shared lCopyAndPaste[50] as double                           '通道数据拷贝中间变量long数组
dim shared lCurRowNum as long                                    '水平码垛判断当前工件所在排数用的变量
dim shared lCalcWorkPieceNum as long                             '用于点位计算的工件数

'*******************************点位在不同坐标系下变换******************************************************************
common shared glTempCoordinate as generic location               '临时坐标系
common shared glTempVerCoordinate as generic location            '垂直码垛临时坐标系


'*****************************垂直码垛计算专用*************************************************************************
dim shared glVerActualPltPoint as generic location                '经过计算后每个工件的实际码垛点
dim shared glVerActualDepltPoint as generic location              '经过计算后每个工件的实际拆垛点
dim shared glVerSCompTempLoc as generic location                  '用于单组路径比较点位的临时变量
dim shared glVerTranTempLoc as generic location                   '用于趋近点运动、回退点运动过渡用的变量
dim shared glVerDCompTempLoc[2] as generic location               '用于双组路径比较点位的临时变量
dim shared glVerOneLoc as generic location                        '用于计算实际的趋近点、回退点的点位变量1
dim shared glVerTwoLoc as generic location                        '用于计算实际的趋近点、回退点的点位变量2
dim shared glVerThreeLoc as generic location                      '用于计算实际的趋近点、回退点的点位变量3
dim shared glVerDeltaVal as generic location                      '△值，用于求解点位的位姿变换
dim shared glVerInverPT as generic location                       '点位Inverse求逆
dim shared glVerSinActualAppPoint as generic location             '单组路径实际的趋近点
dim shared glVerSinActualBackPoint as generic location            '单组路径实际的回退点
dim shared glVerDouActualAppPoint[2] as generic location          '双组路径实际的趋近点
dim shared glVerDouActualBackPoint[2] as generic location         '双组路径实际的回退点

dim shared glVerCopyAndPasteAr[20] as generic location            '垂直码垛通道数据拷贝中间变量gl数组
dim shared lVerCopyAndPaste[20] as double                         '通道数据拷贝中间变量long数组

dim shared lCalcColumnCount as long                               '垂直码垛计算的列数
dim shared lCalcRowCount as long                                  '垂直码垛计算的行数
'***********************************************************************************************************************
' function Name: setStackType
' Description: 水平码垛设置码垛方式
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    TypeValue-为码垛的类型，1-表示码垛，2-表示拆垛
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setStackType(byval TotalArrayIndex as long,byval TypeValue as long ) as long
   dim lRet as long = -1
   if TypeValue <> 1 and TypeValue <> 2 then
	  lRet=-1
	  print "The input value is invalid!"
   else
	  TotalPltArray[TotalArrayIndex]->lStackType=TypeValue
      ?saveNewPltData
	  lRet=0
   end if
   setStackType=lRet
end function

'***********************************************************************************************************************
' function Name: getStackType
' Description: 获取水平码垛设置码垛方式
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    lStackType-实际的码垛方式
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getStackType(byval TotalArrayIndex as long) as long
   getStackType=TotalPltArray[TotalArrayIndex]->lStackType
end function

'***********************************************************************************************************************
' function Name: setHorVerNum
' Description: 设置水平/垂直码垛通道号
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    HorOrVer-水平码垛或垂直码垛，1-表示水平Hor,2-表示垂直Ver
'                    Index-通道号,从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setHorVerNum(byval HorOrVer as long,byval Index as long ) as long
   dim lRet as long = -1
	if HorOrVer <>1 and HorOrVer <> 2 then
	    lRet=-1
		print "The input value is invalid!"
	else
		select case HorOrVer
			case 1
				lHorChannelNum=Index
			case 2
				lVerChannelNum=Index
		end select
		?saveNewPltData
		?saveNewVerPltData
	    lRet=0
	end if
   setHorVerNum=lRet
end function

'***********************************************************************************************************************
' function Name: getHorVerNum
' Description: 获取码垛类别及通道号
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    HorOrVer-水平码垛或垂直码垛，1-表示水平Hor,2-表示垂直Ver
' Output Parameters: long 
'                    lStackType-实际的码垛方式
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getHorVerNum(byval HorOrVer as long) as long
   select case HorOrVer
     case 1
	    getHorVerNum=lHorChannelNum
	 case 2
	    getHorVerNum=lVerChannelNum
   end select
end function

'***********************************************************************************************************************
' function Name: setVerStackType
' Description: 垂直码垛设置码垛方式
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
'                    TypeValue-为码垛的类型，1-表示码垛，2-表示拆垛
' Output Parameters: long 
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerStackType(byval TotalVerArrayIndex as long,byval TypeValue as long ) as long
   dim lRet as long = -1
	if TypeValue <> 1 and TypeValue <> 2 then
	    lRet = -1
		print "The input value is invalid!"
	else
		TotalVerPltArray[TotalVerArrayIndex]->lVerStackType=TypeValue
		?saveNewVerPltData			
	    lRet = 0
	end if
   setVerStackType=lRet
end function

'***********************************************************************************************************************
' function Name: getVerStackType
' Description: 获取垂直码垛设置码垛方式
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    lVerStackType-实际的码垛方式
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerStackType(byval TotalVerArrayIndex as long) as long
   getVerStackType=TotalVerPltArray[TotalVerArrayIndex]->lVerStackType
end function

'***********************************************************************************************************************
' function Name: setRowCount
' Description: 水平码垛设置总的排数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    CountVal-数量
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setRowCount(byval TotalArrayIndex as long,byval CountVal as long ) as long
   dim lRet as long = -1
	if CountVal < 0 then
	    lRet = -1
		print "The input value is invalid!"
	else
		TotalPltArray[TotalArrayIndex]->lAllRowCount=CountVal
		?saveNewPltData			
	    lRet = 0
	end if
   setRowCount=lRet
end function

'***********************************************************************************************************************
' function Name: getRowCount
' Description: 获取水平码垛的总排数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    lAllRowCount-总的排数
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getRowCount(byval TotalArrayIndex as long) as long
   getRowCount=TotalPltArray[TotalArrayIndex]->lAllRowCount
end function

'***********************************************************************************************************************
' function Name: setStartPoint
' Description: 水平码垛设置多排码垛的起始点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    SubIndex-为码垛的排数索引，从1开始，上限值为5
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************



public function setStartPoint(byval TotalArrayIndex as long,byval SubIndex as long) as long
   dim lRet as long = -1
   '***************************记录点位之前记录当前示教点的的坐标系环境*************************************************
   TotalPltArray[TotalArrayIndex]->glOriginalBase=Base
   TotalPltArray[TotalArrayIndex]->glOriginalTool=Tool
   TotalPltArray[TotalArrayIndex]->glOriginalworkpiece=workpiece
   TotalPltArray[TotalArrayIndex]->glOriginalMachineTable=MachineTable			
	if SubIndex > 5 or SubIndex < 0 then
	    lRet = -1
		print "The input value is invalid!"
	else
		TotalPltArray[TotalArrayIndex]->glStartPoint[SubIndex]=here
		?saveNewPltData			
	    lRet = 0
	end if
   setStartPoint=lRet
end function

'***********************************************************************************************************************
' function Name: getStartPoint
' Description: 获取水平码垛多排码垛的起始点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    SubIndex-为码垛的排数索引，从1开始，上限值为5
' Output Parameters: generic location 
'                    glStartPoint[]-多排码垛起始点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getStartPoint(byval TotalArrayIndex as long,byval SubIndex as long) as generic location
   getStartPoint=TotalPltArray[TotalArrayIndex]->glStartPoint[SubIndex]
end function

'***********************************************************************************************************************
' function Name: setVerPltRefPointOne
' Description: 垂直码垛设置参考点1
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerPltRefPointOne(byval TotalVerArrayIndex as long) as long
   '***************************记录点位之前记录当前示教点的的坐标系环境*************************************************
   TotalVerPltArray[TotalVerArrayIndex]->glVerOriginalBase=Base
   TotalVerPltArray[TotalVerArrayIndex]->glVerOriginalTool=Tool
   TotalVerPltArray[TotalVerArrayIndex]->glVerOriginalworkpiece=workpiece
   TotalVerPltArray[TotalVerArrayIndex]->glVerOriginalMachineTable=MachineTable

   TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne=here
   ?saveNewVerPltData
   setVerPltRefPointOne=0
end function

'***********************************************************************************************************************
' function Name: getVerPltRefPointOne
' Description: 获取垂直码垛参考点1
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glVerRefPointOne-码垛参考点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerPltRefPointOne(byval TotalVerArrayIndex as long) as generic location
   getVerPltRefPointOne=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne

end function

'***********************************************************************************************************************
' function Name: setVerPltRefPointTwo
' Description: 垂直码垛设置参考点2
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerPltRefPointTwo(byval TotalVerArrayIndex as long) as long
   TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointTwo=here
   ?saveNewVerPltData
   setVerPltRefPointTwo=0
end function

'***********************************************************************************************************************
' function Name: getVerPltRefPointTwo
' Description: 获取垂直码垛参考点2
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glVerRefPointTwo-码垛参考点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerPltRefPointTwo(byval TotalVerArrayIndex as long) as generic location
   getVerPltRefPointTwo=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointTwo
end function

'***********************************************************************************************************************
' function Name: setVerPltRefPointThree
' Description: 垂直码垛设置参考点3
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerPltRefPointThree(byval TotalVerArrayIndex as long) as long
   TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointThree=here
   ?saveNewVerPltData
   setVerPltRefPointThree=0
end function

'***********************************************************************************************************************
' function Name: getVerPltRefPointThree
' Description: 获取垂直码垛参考点3
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glVerRefPointThree-码垛参考点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerPltRefPointThree(byval TotalVerArrayIndex as long) as generic location
   getVerPltRefPointThree=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointThree
end function

'***********************************************************************************************************************
' function Name: setTermPoint
' Description: 水平码垛设置多排码垛的终止点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    SubIndex-为码垛的排数索引，从1开始，上限值为5
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setTermPoint(byval TotalArrayIndex as long,byval SubIndex as long) as long
   dim lRet as long = -1
   dim glTempPint as generic location
   glTempPint=here
   glTempPint{3}=TotalPltArray[TotalArrayIndex]->glStartPoint[SubIndex]{3}
	if SubIndex > 5 or SubIndex < 0 then
		lRet = -1
		print "The input value is invalid!"
	else
		TotalPltArray[TotalArrayIndex]->glTermPoint[SubIndex]=glTempPint
		?saveNewPltData			
		lRet = 0
	end if
   setTermPoint=lRet
end function

'***********************************************************************************************************************
' function Name: getTermPoint
' Description: 获取水平码垛多排码垛的终止点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    SubIndex-为码垛的排数索引，从1开始，上限值为5
' Output Parameters: generic location 
'                    glTermPoint[]-多排码垛终止点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getTermPoint(byval TotalArrayIndex as long,byval SubIndex as long) as generic location
   getTermPoint=TotalPltArray[TotalArrayIndex]->glTermPoint[SubIndex]
end function

'***********************************************************************************************************************
' function Name: setSinRefPoint
' Description: 水平码垛设置单组路径参考点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setSinRefPoint(byval TotalArrayIndex as long) as long
   TotalPltArray[TotalArrayIndex]->glSinRefPoint=here
   ?saveNewPltData
   setSinRefPoint=0
end function

'***********************************************************************************************************************
' function Name: getSinRefPoint
' Description: 获取水平码垛单组路径参考点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glSinRefPoint-单组路径参考点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getSinRefPoint(byval TotalArrayIndex as long) as generic location
   getSinRefPoint=TotalPltArray[TotalArrayIndex]->glSinRefPoint
end function

'***********************************************************************************************************************
' function Name: setVerSinRefPoint
' Description: 垂直码垛设置指定通道的单组路径参考点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerSinRefPoint(byval TotalVerArrayIndex as long) as long
   TotalVerPltArray[TotalVerArrayIndex]->glVerSinRefPoint=here
   ?saveNewVerPltData
   setVerSinRefPoint=0
end function

'***********************************************************************************************************************
' function Name: getVerSinRefPoint
' Description: 获取垂直码垛参考点2
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glVerSinRefPoint-码垛参考点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerSinRefPoint(byval TotalVerArrayIndex as long) as generic location
   getVerSinRefPoint=TotalVerPltArray[TotalVerArrayIndex]->glVerSinRefPoint
end function

'***********************************************************************************************************************
' function Name: setSinApproachPoint
' Description: 水平码垛设置单组路径趋近点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setSinApproachPoint(byval TotalArrayIndex as long) as long
   TotalPltArray[TotalArrayIndex]->glSinApproachPoint=here
   ?saveNewPltData
   setSinApproachPoint=0
end function

'***********************************************************************************************************************
' function Name: getSinApproachPoint
' Description: 获取水平码垛指定通道的单组路径趋近点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glSinApproachPoint-指定通道的单组路径趋近点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getSinApproachPoint(byval TotalArrayIndex as long) as generic location
   getSinApproachPoint=TotalPltArray[TotalArrayIndex]->glSinApproachPoint
end function

'***********************************************************************************************************************
' function Name: setVerSinApproachPoint
' Description: 垂直码垛设置指定通道的单组路径趋近点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerSinApproachPoint(byval TotalVerArrayIndex as long) as long
   TotalVerPltArray[TotalVerArrayIndex]->glVerSinApproachPoint=here
   ?saveNewVerPltData
   setVerSinApproachPoint=0
end function

'***********************************************************************************************************************
' function Name: getVerSinApproachPoint
' Description: 获取垂直码垛指定通道的单组路径趋近点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glVerSinApproachPoint-垂直码垛指定通道的单组路径趋近点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerSinApproachPoint(byval TotalVerArrayIndex as long) as generic location
   getVerSinApproachPoint=TotalVerPltArray[TotalVerArrayIndex]->glVerSinApproachPoint
end function

'***********************************************************************************************************************
' function Name: setDouRefPoint
' Description: 水平码垛设置指定通道的双组路径参考点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setDouRefPoint(byval TotalArrayIndex as long) as long
   TotalPltArray[TotalArrayIndex]->glDouRefPoint=here
   ?saveNewPltData
   setDouRefPoint=0
end function

'***********************************************************************************************************************
' function Name: getDouRefPoint
' Description: 水平码垛获取指定通道的双组路径参考点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    SubIndex-为码垛的排数索引，从1开始，上限值为5
' Output Parameters: generic location 
'                    glDouRefPoint-双组路径参考点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getDouRefPoint(byval TotalArrayIndex as long) as generic location
   getDouRefPoint=TotalPltArray[TotalArrayIndex]->glDouRefPoint
end function

'***********************************************************************************************************************
' function Name: setVerDouRefPoint
' Description: 垂直码垛设置指定通道的双组路径参考点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerDouRefPoint(byval TotalVerArrayIndex as long) as long
   TotalVerPltArray[TotalVerArrayIndex]->glVerDouRefPoint=here
   ?saveNewVerPltData
   setVerDouRefPoint=0
end function

'***********************************************************************************************************************
' function Name: getVerDouRefPoint
' Description: 获取垂直码垛指定通道的双组路径参考点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glVerDouRefPoint-垂直码垛指定通道的双组路径参考点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerDouRefPoint(byval TotalVerArrayIndex as long) as generic location
   getVerDouRefPoint=TotalVerPltArray[TotalVerArrayIndex]->glVerDouRefPoint
end function

'***********************************************************************************************************************
' function Name: setDouApproachPoint
' Description: 水平码垛设置指定通道的双组路径趋近点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    PathIndex-为点位数组索引，  索引从1开始，上限值为2
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setDouApproachPoint(byval TotalArrayIndex as long,byval PathIndex as long) as long
   TotalPltArray[TotalArrayIndex]->glDouApproachPoint[PathIndex]=here  
   ?saveNewPltData
   setDouApproachPoint=0
end function

'***********************************************************************************************************************
' function Name: getDouApproachPoint
' Description: 获取水平码垛指定通道的双组路径趋近点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    PathIndex-为点位数组索引，  索引从1开始，上限值为2
' Output Parameters: generic location 
'                    glDouApproachPoint[]-双组路径趋近点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getDouApproachPoint(byval TotalArrayIndex as long,byval PathIndex as long) as generic location
   getDouApproachPoint=TotalPltArray[TotalArrayIndex]->glDouApproachPoint[PathIndex]
end function

'***********************************************************************************************************************
' function Name: setVerDouApproachPoint
' Description: 垂直码垛设置指定通道的双组路径趋近点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    PathIndex-为点位数组索引，  索引从1开始，上限值为2
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerDouApproachPoint(byval TotalVerArrayIndex as long,byval PathIndex as long) as long
   TotalVerPltArray[TotalVerArrayIndex]->glVerDouApproachPoint[PathIndex]=here  
   ?saveNewVerPltData
   setVerDouApproachPoint=0
end function

'***********************************************************************************************************************
' function Name: getVerDouApproachPoint
' Description: 获取垂直码垛指定通道的双组路径趋近点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
'                    PathIndex-为点位数组索引，  索引从1开始，上限值为2
' Output Parameters: generic location 
'                    glVerDouApproachPoint-垂直码垛双组路径趋近点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerDouApproachPoint(byval TotalVerArrayIndex as long,byval PathIndex as long) as generic location
   getVerDouApproachPoint=TotalVerPltArray[TotalVerArrayIndex]->glVerDouApproachPoint[PathIndex]
end function

'***********************************************************************************************************************
' function Name: setSinBackPoint
' Description: 水平码垛设置指定通道的单组路径回退点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setSinBackPoint(byval TotalArrayIndex as long) as long
   TotalPltArray[TotalArrayIndex]->glSinBackPoint=here
   ?saveNewPltData
   setSinBackPoint=0
end function

'***********************************************************************************************************************
' function Name: getSinBackPoint
' Description: 获取水平码垛指定通道的单组路径回退点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glSinBackPoint-单组路径回退点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getSinBackPoint(byval TotalArrayIndex as long) as generic location
   getSinBackPoint=TotalPltArray[TotalArrayIndex]->glSinBackPoint
end function

'***********************************************************************************************************************
' function Name: setVerSinBackPoint
' Description: 垂直码垛设置指定通道的单组路径回退点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerSinBackPoint(byval TotalVerArrayIndex as long) as long
   TotalVerPltArray[TotalVerArrayIndex]->glVerSinBackPoint=here
   ?saveNewVerPltData
   setVerSinBackPoint=0
end function

'***********************************************************************************************************************
' function Name: getVerSinBackPoint
' Description: 获取垂直码垛指定通道的单组路径回退点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glVerSinBackPoint-垂直码垛指定通道的单组路径回退点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerSinBackPoint(byval TotalVerArrayIndex as long) as generic location
   getVerSinBackPoint=TotalVerPltArray[TotalVerArrayIndex]->glVerSinBackPoint
end function

'***********************************************************************************************************************
' function Name: setDouBackPoint
' Description: 水平码垛设置指定通道的双组路径回退点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    PathIndex-为点位数组索引，  索引从1开始，上限值为2
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setDouBackPoint(byval TotalArrayIndex as long,byval PathIndex as long) as long 
   dim lRet as long = -1
	if PathIndex <> 1 and PathIndex <> 2 then
		lRet = -1
		print "The input value is invalid!"
	else
		TotalPltArray[TotalArrayIndex]->glDouBackPoint[PathIndex]=here
		?saveNewPltData			
		lRet = 0
	end if
   setDouBackPoint=lRet
end function

'***********************************************************************************************************************
' function Name: getDouBackPoint
' Description: 获取水平码垛指定通道的双组路径回退点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    PathIndex-为点位数组索引，  索引从1开始，上限值为2
' Output Parameters: generic location 
'                    glDouBackPoint[]-指定通道的双组路径回退点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getDouBackPoint(byval TotalArrayIndex as long,byval PathIndex as long) as generic location 
   getDouBackPoint=TotalPltArray[TotalArrayIndex]->glDouBackPoint[PathIndex]

end function

'***********************************************************************************************************************
' function Name: setVerDouBackPoint
' Description: 垂直码垛设置指定通道的双组路径回退点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    PathIndex-为点位数组索引，  索引从1开始，上限值为2
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerDouBackPoint(byval TotalVerArrayIndex as long,byval PathIndex as long) as long 
   dim lRet as long = -1
	if PathIndex <> 1 and PathIndex <> 2 then
		lRet = -1
		print "The input value is invalid!"
	else			
		TotalVerPltArray[TotalVerArrayIndex]->glVerDouBackPoint[PathIndex]=here
		?saveNewVerPltData
		lRet=0
	end if
   setVerDouBackPoint=lRet
end function

'***********************************************************************************************************************
' function Name: getVerDouBackPoint
' Description: 获取垂直码垛指定通道的双组路径回退点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
'                    PathIndex-为点位数组索引，  索引从1开始，上限值为2
' Output Parameters: generic location 
'                    glVerDouBackPoint[]-垂直码垛指定通道的双组路径回退点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerDouBackPoint(byval TotalVerArrayIndex as long,byval PathIndex as long) as generic location 
   getVerDouBackPoint=TotalVerPltArray[TotalVerArrayIndex]->glVerDouBackPoint[PathIndex]
end function

'***********************************************************************************************************************
' function Name: setLmJumpRefPoint
' Description: 水平码垛设置龙门跳路径参考点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setLmJumpRefPoint(byval TotalArrayIndex as long) as long
   TotalPltArray[TotalArrayIndex]->glLmJumpRefPoint=here
   ?saveNewPltData
   setLmJumpRefPoint=0
end function

'***********************************************************************************************************************
' function Name: getLmJumpRefPoint
' Description: 获取水平码垛龙门跳路径参考点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glLmJumpRefPoint-单组路径参考点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getLmJumpRefPoint(byval TotalArrayIndex as long) as generic location
   getLmJumpRefPoint=TotalPltArray[TotalArrayIndex]->glLmJumpRefPoint
end function

'***********************************************************************************************************************
' function Name: setLmJumpTransPoint
' Description: 水平码垛设置龙门跳路径过渡点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setLmJumpTransPoint(byval TotalArrayIndex as long) as long
   TotalPltArray[TotalArrayIndex]->glLmJumpTransPoint=here
   ?saveNewPltData
   setLmJumpTransPoint=0
end function

'***********************************************************************************************************************
' function Name: getLmJumpTransPoint
' Description: 获取水平码垛龙门跳路径过渡点
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: generic location 
'                    glLmJumpTransPoint-龙门跳路径过渡点位
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getLmJumpTransPoint(byval TotalArrayIndex as long) as generic location
   getLmJumpTransPoint=TotalPltArray[TotalArrayIndex]->glLmJumpTransPoint
end function

'***********************************************************************************************************************
' function Name: setlengthofWorkpiece
' Description: 垂直码垛设置每个工件的的长度
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long, double
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    lengthValue-长度值
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setlengthofWorkpiece(byval TotalVerArrayIndex as long,byval lengthValue as double) as long
   dim lRet as long = -1
   dim StrVal as string
   if lengthValue < 0 then
        lRet=-1
		print "The input value is invalid!"
   else
		printu$ StrVal,"#.##";lengthValue
		lengthValue=Val(StrVal)
		TotalVerPltArray[TotalVerArrayIndex]->llengthofWorkpiece=lengthValue
		?saveNewVerPltData 
		lRet=0
   end if 
   setlengthofWorkpiece=lRet 
end function

'***********************************************************************************************************************
' function Name: getlengthofWorkpiece
' Description: 获取垂直码垛每个工件的的长度
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    llengthofWorkpiece-工件长度
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getlengthofWorkpiece(byval TotalVerArrayIndex as long) as double
   getlengthofWorkpiece=TotalVerPltArray[TotalVerArrayIndex]->llengthofWorkpiece
end function

'***********************************************************************************************************************
' function Name: setWidthofWorkpiece
' Description: 垂直码垛设置每个工件的的宽度
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    WidthValue-宽度值
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setWidthofWorkpiece(byval TotalVerArrayIndex as long,byval WidthValue as double) as long
   dim lRet as long = -1
   dim StrVal as string
   if WidthValue < 0 then
        lRet=-1
		print "The input value is invalid!"
   else
		printu$ StrVal,"#.##";WidthValue
		WidthValue=Val(StrVal)
		TotalVerPltArray[TotalVerArrayIndex]->lWidthofWorkpiece=WidthValue
		?saveNewVerPltData
		lRet=0
   end if
   setWidthofWorkpiece=lRet
end function

'***********************************************************************************************************************
' function Name: getWidthofWorkpiece
' Description: 获取垂直码垛每个工件的的宽度
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    lWidthofWorkpiece-工件宽度
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getWidthofWorkpiece(byval TotalVerArrayIndex as long) as double
   getWidthofWorkpiece=TotalVerPltArray[TotalVerArrayIndex]->lWidthofWorkpiece
end function

'***********************************************************************************************************************
' function Name: setHeightofWorkpiece
' Description: 垂直码垛设置每个工件的的高度
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    HeighValue-高度值
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setHeightofWorkpiece(byval TotalVerArrayIndex as long,byval HeighValue as double) as long
   dim lRet as long = -1
   dim StrVal as string
   if HeighValue < 0 then
        lRet=-1
		print "The input value is invalid!"
   else
		printu$ StrVal,"#.##";HeighValue
		HeighValue=Val(StrVal)			   
		TotalVerPltArray[TotalVerArrayIndex]->lHeightofWorkpiece=HeighValue
		?saveNewVerPltData
		lRet=0
   end if
   setHeightofWorkpiece=lRet
end function

'***********************************************************************************************************************
' function Name: getHeightofWorkpiece
' Description: 获取垂直码垛每个工件的的高度
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    lHeightofWorkpiece-工件高度
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getHeightofWorkpiece(byval TotalVerArrayIndex as long) as double
   getHeightofWorkpiece=TotalVerPltArray[TotalVerArrayIndex]->lHeightofWorkpiece
end function

'***********************************************************************************************************************
' function Name: setVerPltAllPlies
' Description: 垂直码垛设置垂直码垛工件的总层数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    PliesCntValue-层数值
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerPltAllPlies(byval TotalVerArrayIndex as long,byval PliesCntValue as long) as long
   dim lRet as long = -1
	if PliesCntValue <= 0 then
	    lRet = -1
		Print "The total number of layers of Workpiece  must be Greater than Zero!"
	else
		TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies=PliesCntValue
		?saveNewVerPltData			
	    lRet = 0
	end if
    setVerPltAllPlies=lRet
end function

'***********************************************************************************************************************
' function Name: getVerPltAllPlies
' Description: 获取垂直码垛工件的总层数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    lVerNumofPlies-工件层数
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerPltAllPlies(byval TotalVerArrayIndex as long) as long
   getVerPltAllPlies=TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies
end function

'***********************************************************************************************************************
' function Name: setVerRowSpacing
' Description: 垂直码垛设置垂直码垛当前通道每层的行间距
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    SpacingValue-工件间距
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerRowSpacing(byval TotalVerArrayIndex as long,byval SpacingValue as double) as long
   dim lRet as long = -1
   dim StrVal as string
   if SpacingValue < 0 then
        lRet=-1
		Print "Workpiece row Spacing must be Greater than Zero!"
   else
		printu$ StrVal,"#.##";SpacingValue
		SpacingValue=Val(StrVal)	       
		TotalVerPltArray[TotalVerArrayIndex]->lRowSpacing=SpacingValue
		?saveNewVerPltData
		lRet = 0
  end if
  setVerRowSpacing=lRet
end function

'***********************************************************************************************************************
' function Name: getVerRowSpacing
' Description: 获取垂直码垛工件的行间距
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    lRowSpacing-工件行间距
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerRowSpacing(byval TotalVerArrayIndex as long) as double
   getVerRowSpacing=TotalVerPltArray[TotalVerArrayIndex]->lRowSpacing
end function

'***********************************************************************************************************************
' function Name: setVerColumnSpacing
' Description: 垂直码垛设置垂直码垛当前通道每层的列间距
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    SpacingValue-工件间距
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerColumnSpacing(byval TotalVerArrayIndex as long,byval SpacingValue as double) as long
   dim lRet as long = -1
   dim StrVal as string
   if SpacingValue < 0 then
        lRet=-1
	    Print "Workpiece Column Spacing must be Greater than Zero!"
   else
		printu$ StrVal,"#.##";SpacingValue
		SpacingValue=Val(StrVal)	 			
		TotalVerPltArray[TotalVerArrayIndex]->lColumnSpacing=SpacingValue
		?saveNewVerPltData
		lRet=0
   end if
   setVerColumnSpacing=lRet
end function

'***********************************************************************************************************************
' function Name: getVerColumnSpacing
' Description: 获取垂直码垛工件的列间距
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    lColumnSpacing-工件列间距
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerColumnSpacing(byval TotalVerArrayIndex as long) as double
   getVerColumnSpacing=TotalVerPltArray[TotalVerArrayIndex]->lColumnSpacing
end function

'***********************************************************************************************************************
' function Name: setHeightofClapBoard
' Description: 垂直码垛设置当前通道每层隔板的高度
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    HeightValue-高度值
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setHeightofClapBoard(byval TotalVerArrayIndex as long,byval HeightValue as double) as long
   dim lRet as long = -1
   dim StrVal as string
   if HeightValue < 0 then
		lRet=-1
		Print "Partition HeightValue must be Greater than Zero!"
   else
		printu$ StrVal,"#.##";HeightValue
		HeightValue=Val(StrVal)	
		TotalVerPltArray[TotalVerArrayIndex]->lHeightofClapBoard=HeightValue
		?saveNewVerPltData
		lRet=0
   end if
   setHeightofClapBoard=lRet
end function

'***********************************************************************************************************************
' function Name: setVerToolFrameNum
' Description: 垂直码垛设置当前选择的工具编号
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    HeightValue-高度值
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerToolFrameNum(byval TotalVerArrayIndex as long,byval ToolNumber as long)as long
  if ToolNumber = 0 then
	Robot.Tool=Tool_Frame_original
	toolframenum = 0
	TotalVerPltArray[TotalVerArrayIndex]-> lVerToolFrameNum=ToolNumber
	goto endsetToolNum
  else
    Robot.Tool=Tool_Frame[ToolNumber]
	toolframenum = ToolNumber
	TotalVerPltArray[TotalVerArrayIndex]-> lVerToolFrameNum=ToolNumber
	goto endsetToolNum
  end if    
  endsetToolNum:
  setVerToolFrameNum=0
end function

'***********************************************************************************************************************
' function Name: getVerToolFrameNum
' Description: 垂直码垛获取当前选择的工具编号
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    HeightValue-高度值
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerToolFrameNum(byval TotalVerArrayIndex as long)as long
  getVerToolFrameNum=TotalVerPltArray[TotalVerArrayIndex]-> lVerToolFrameNum
end function

'***********************************************************************************************************************
' function Name: getHeightofClapBoard
' Description: 获取垂直码垛每层隔板的高度
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    lHeightofClapBoard-隔板高度/厚度
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getHeightofClapBoard(byval TotalVerArrayIndex as long) as double
   getHeightofClapBoard=TotalVerPltArray[TotalVerArrayIndex]->lHeightofClapBoard
end function

'***********************************************************************************************************************
' function Name: setAllCount
' Description: 水平码垛设置当前通道单排的工件总数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    AllCount-工件数量 
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setAllCount(byval TotalArrayIndex as long, byval AllCount as long) as long
   dim lRet as long = -1
   if AllCount <=0 then
        lRet = -1
        print "The total number of workpiece must be greater than zero!"						
   else
		TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt=AllCount
		?saveNewPltData			
		lRet = 0
   end if
   setAllCount=lRet
end function

'***********************************************************************************************************************
' function Name: getAllCount
' Description: 获取当前通道单排的工件总数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    lAllWorkpieceCnt-工件总数 
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getAllCount(byval TotalArrayIndex as long) as long
   getAllCount=TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt
end function

'***********************************************************************************************************************
' function Name: setCurrWorkpieceCnt
' Description: 水平码垛设置当前通道已经码垛/拆垛的工件数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    CountVal-数量值 
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setCurrWorkpieceCnt(byval TotalArrayIndex as long,byval CountVal as long) as long
   dim lRet as long=-1 
   '*******************判断码垛还是拆垛，将当前工件数赋值给相应的变量***************************************************
   if TotalPltArray[TotalArrayIndex]->lStackType=0 then
            lRet=-1
			print "The value of palletizing type is not set! "
	        goto endsetCurwpCnt
   end if
   if TotalPltArray[TotalArrayIndex]->lStackType=1 then
      if CountVal>=0 and CountVal< TotalPltArray[TotalArrayIndex]->lAllRowCount*TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt then
			TotalPltArray[TotalArrayIndex]->lCurrPalletNum=CountVal
			?saveNewPltData
			lRet=0
			goto endsetCurwpCnt
      else 
	        lRet=-1
			print "The current number of workpiece exceeds the limit! "
		    goto endsetCurwpCnt
      end if	  
   end if
   
   if TotalPltArray[TotalArrayIndex]->lStackType=2 then
      if CountVal>=0 and CountVal< TotalPltArray[TotalArrayIndex]->lAllRowCount*TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt then
			TotalPltArray[TotalArrayIndex]->lCurrDepalletNum=CountVal 
			?saveNewPltData
			lRet=0
			goto endsetCurwpCnt
      else
            lRet=-1
			print "The current number of workpiece exceeds the limit! "
		    goto endsetCurwpCnt									
      end if		
   end if  
   endsetCurwpCnt:
   setCurrWorkpieceCnt=lRet
end function

'***********************************************************************************************************************
' function Name: getCurrWorkpieceCnt
' Description: 获取当前通道已经码垛/拆垛的工件数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    lCurrPalletNum-当前已经码垛的工件数
'                    lCurrDepalletNum-当前已经拆垛的工件数 
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getCurrWorkpieceCnt(byval TotalArrayIndex as long) as long
   if TotalPltArray[TotalArrayIndex]->lStackType=0 then
      getCurrWorkpieceCnt=-1
   end if
   if TotalPltArray[TotalArrayIndex]->lStackType=1 then
      getCurrWorkpieceCnt=TotalPltArray[TotalArrayIndex]->lCurrPalletNum
   end if
   if TotalPltArray[TotalArrayIndex]->lStackType=2 then
      getCurrWorkpieceCnt=TotalPltArray[TotalArrayIndex]->lCurrDepalletNum
   end if   
end function

'***********************************************************************************************************************
' function Name: setVerCurrWorkpieceCnt
' Description: 垂直码垛设置当前通道已经码垛的工件数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    CountVal-数量值
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerCurrWorkpieceCnt(byval TotalVerArrayIndex as long,byval CountVal as long) as long
   dim lRet as long = -1
   if TotalVerPltArray[TotalVerArrayIndex]->lVerStackType <> 0 then
		if CountVal>=0 and CountVal< lVerPltAllWPCount[TotalVerArrayIndex] then
			TotalVerPltArray[TotalVerArrayIndex]->lVerCurrPalletNum=CountVal
			?saveNewVerPltData
			lRet=0
			goto endsetVerCurrWPCnt
		else
			lRet=-1
			print "The current number of workpiece exceeds the limit! "
			goto endsetVerCurrWPCnt
		end if
	  else
			lRet=-1
			print "The value of palletizing type is not set! "
	        goto endsetVerCurrWPCnt
   end if 	
   endsetVerCurrWPCnt:  
   setVerCurrWorkpieceCnt=lRet
end function

'***********************************************************************************************************************
' function Name: getVerCurrWorkpieceCnt
' Description: 获取垂直码垛当前通道已经码垛的工件数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    lVerCurrPalletNum-当前已经码垛工件数
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerCurrWorkpieceCnt(byval TotalVerArrayIndex as long) as long
   getVerCurrWorkpieceCnt=TotalVerPltArray[TotalVerArrayIndex]->lVerCurrPalletNum
end function

'***********************************************************************************************************************
' function Name: setVerDepltCurrWorkpieceCnt
' Description: 垂直码垛设置当前通道已经拆垛的工件数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    CountVal-数量值
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerDepltCurrWorkpieceCnt(byval TotalVerArrayIndex as long,byval CountVal as long) as long
   dim lRet as long =-1
   if TotalVerPltArray[TotalVerArrayIndex]->lVerStackType <> 0 then
		if CountVal>=0 and CountVal< lVerPltAllWPCount[TotalVerArrayIndex] then
			TotalVerPltArray[TotalVerArrayIndex]->lVerCurrDepalletNum=CountVal
			?saveNewVerPltData
			lRet=0
			goto endsetVerDepWPcnt
		else
			lRet=-1
			print "The current number of workpiece exceeds the limit! "
			goto endsetVerDepWPcnt
		end if
   else
		lRet=-1
		print "The value of palletizing type is not set! "
		goto endsetVerDepWPcnt
   end if   
	endsetVerDepWPcnt:
	   setVerDepltCurrWorkpieceCnt=lRet
end function

'***********************************************************************************************************************
' function Name: getVerDepltCurrWorkpieceCnt
' Description: 获取垂直码垛当前通道已经拆垛的工件数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long 
'                    lVerCurrDepalletNum-当前已经拆垛工件数
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerDepltCurrWorkpieceCnt(byval TotalVerArrayIndex as long) as long
   getVerDepltCurrWorkpieceCnt=TotalVerPltArray[TotalVerArrayIndex]->lVerCurrDepalletNum
end function

'***********************************************************************************************************************
' function Name: setLiftHeight
' Description: 水平码垛设置设置龙门跳的抬起高度值
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long,double
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    HeightVal-高度值 
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setLiftHeight(byval TotalArrayIndex as long,byval HeightVal as double) as long
   dim lRet as long = -1
   dim StrVal as string
   if HeightVal < 0 then
	    lRet = -1
		print "The input value  is invalid! "
	else
		printu$ StrVal,"#.##";HeightVal
		HeightVal=Val(StrVal)
		TotalPltArray[TotalArrayIndex]->lLiftHeight=HeightVal
		?saveNewPltData			
	    lRet =0
   end if
   setLiftHeight=lRet
end function

'***********************************************************************************************************************
' function Name: getLiftHeight
' Description: 获取龙门跳抬起的高度
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    lLiftHeight-抬起的高度 
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getLiftHeight(byval TotalArrayIndex as long) as long
   getLiftHeight=TotalPltArray[TotalArrayIndex]->lLiftHeight
end function

'***********************************************************************************************************************
' function Name: setMotPathFlag
' Description: 水平码垛设置码垛路径选择的标志位
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    pathType-路径类型值，1-代表单组，2-代表双组，3-代表龙门跳 
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setMotPathFlag(byval TotalArrayIndex as long,byval pathType as long)as long
  dim i as long
  dim k as long
  dim lRet as long = -1
		dim lFuncRet as long = -1
  dim lSinPointCnt as long = 0
  dim lDouPointCnt as long = 0 
  
  dim glSinTemp[3] as generic location '单组路径设置Flag临时点位变量
  dim glDouTemp[5] as generic location '双组路径设置Flag临时点位变量
  dim glLmTemp[2] as generic location  '龙门跳路径设置Flag临时点位变量
  
  glSinTemp[1]=TotalPltArray[TotalArrayIndex]->glSinRefPoint
  glSinTemp[2]=TotalPltArray[TotalArrayIndex]->glSinApproachPoint
  glSinTemp[3]=TotalPltArray[TotalArrayIndex]->glSinBackPoint
  
  glDouTemp[1]=TotalPltArray[TotalArrayIndex]->glDouRefPoint
  glDouTemp[2]=TotalPltArray[TotalArrayIndex]->glDouApproachPoint[1]
  glDouTemp[3]=TotalPltArray[TotalArrayIndex]->glDouApproachPoint[2]
  glDouTemp[4]=TotalPltArray[TotalArrayIndex]->glDouBackPoint[1]
  glDouTemp[5]=TotalPltArray[TotalArrayIndex]->glDouBackPoint[2]
  
  glLmTemp[1]=TotalPltArray[TotalArrayIndex]->glLmJumpRefPoint
  glLmTemp[2]=TotalPltArray[TotalArrayIndex]->glLmJumpTransPoint
  
'  if TotalPltArray[TotalArrayIndex]->lHorPltMotFlag<>0 then     '运动路径选择标志位清零
'     TotalPltArray[TotalArrayIndex]->lHorPltMotFlag=0
'  end if
'******************************判断单组路径点位是否设置完成**********************************************************
   IF pathType = 1 Then
		for i=1 to 3
			if isPointValue(glSinTemp[i])<>1 then
					lSinPointCnt=lSinPointCnt+1
			end if
		next i

		if lSinPointCnt=3 then 
			lRet=1                      '表示单组路径所有点位都设置了
			GOTO EndsetMotPathFlag      '直接跳出程序，并将单组路径标志位置1
		else
		    lRet=-1                      '表示单组路径点位没有全部设置
		    print "Not all of the single path points are set!"
		end if
   end if
'******************************判断双组路径点位是否设置完成**********************************************************  
   IF pathType = 2 Then
		for k =1 to 5
			if  isPointValue(glDouTemp[k])<>1 then 
					lDouPointCnt=lDouPointCnt+1
			end if  
		next k 
	
		if lDouPointCnt=5 then 
			lRet=2                      '表示双组路径所有点位都设置了
			GOTO EndsetMotPathFlag      '直接跳出程序，并将双组路径标志位置2
		else
		    lRet=-1                      '表示双组路径点位没有全部设置
		    print "Not all of the double path points are set!"
		end if  
   end if
 '*******************************判断龙门跳点位是否设置完成********************************************************** 
   IF pathType = 3 Then
      select case robot.ElementSize
		case 4
			if  isPointValue(glLmTemp[1])<>1 and isPointValue(glLmTemp[2])<>1 then
				lRet=3                      '表示4轴龙门跳设置了参考点和过渡点
				GOTO EndsetMotPathFlag      '直接跳出程序，并将龙门跳标志位置3
			else 
				lRet=-1 
				print "Not all of the LMjump path points are set!"
			end if     
					
		case 6
			if  isPointValue(glLmTemp[1])<>1 and isPointValue(glLmTemp[2])<>1 and TotalPltArray[TotalArrayIndex]->lLiftHeight<>0 then
				lRet=3                      '表示6轴龙门跳设置了参考点和过渡点和高度值
				GOTO EndsetMotPathFlag      '直接跳出程序，并将龙门跳标志位置3
			else 
				lRet=-1  
				print "Not all of the LMjump path points are set!"
			end if     
	  end select
 
   end if
  
  EndsetMotPathFlag:
   IF lRet <> -1 Then
       TotalPltArray[TotalArrayIndex]->lHorPltMotFlag=lRet
       lFuncRet = 0
   else
       lFuncRet = -1
	   print "Not all of the  points are set!"
   end if
   setMotPathFlag=lFuncRet
end function

'***********************************************************************************************************************
' function Name: getMotPathFlag
' Description: 获取水平码垛路径选择的标志位
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    lHorPltMotFlag-路径类型值，1-代表单组，2-代表双组，3-代表龙门跳 
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getMotPathFlag(byval TotalArrayIndex as long)as long
   getMotPathFlag=TotalPltArray[TotalArrayIndex]->lHorPltMotFlag
end function

'***********************************************************************************************************************
' function Name: setVerMotPathFlag
' Description: 垂直码垛设置码垛路径选择的标志位
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function setVerMotPathFlag(byval TotalVerArrayIndex as long,byval pathType as long)as long
  
  dim  i as long 
  dim  k as long 
		dim lRet as long = -1
		dim lFuncRet as long = -1
  dim lVerSinPointCount as long
  dim lVerDouPointCount as long  
  
  dim glVerSinTemp[3] as generic location '垂直码垛单组路径设置Flag临时点位变量
  dim glVerDouTemp[5] as generic location '垂直码垛双组路径设置Flag临时点位变量
  
  glVerSinTemp[1]=TotalVerPltArray[TotalVerArrayIndex]->glVerSinRefPoint
  glVerSinTemp[2]=TotalVerPltArray[TotalVerArrayIndex]->glVerSinApproachPoint
  glVerSinTemp[3]=TotalVerPltArray[TotalVerArrayIndex]->glVerSinBackPoint
  
  glVerDouTemp[1]=TotalVerPltArray[TotalVerArrayIndex]->glVerDouRefPoint
  glVerDouTemp[2]=TotalVerPltArray[TotalVerArrayIndex]->glVerDouApproachPoint[1]
  glVerDouTemp[3]=TotalVerPltArray[TotalVerArrayIndex]->glVerDouApproachPoint[2]
  glVerDouTemp[4]=TotalVerPltArray[TotalVerArrayIndex]->glVerDouBackPoint[1]
  glVerDouTemp[5]=TotalVerPltArray[TotalVerArrayIndex]->glVerDouBackPoint[2]
  
  if TotalVerPltArray[TotalVerArrayIndex]->lVerPltMotFlag<>0 then
    TotalVerPltArray[TotalVerArrayIndex]->lVerPltMotFlag=0
  end if
 '******************************判断单组路径点位是否设置完成**********************************************************
  if pathType=1 then        
	for i = 1 to 3
		if isPointValue(glVerSinTemp[i])<>1 then
					lVerSinPointCount=lVerSinPointCount+1
		end if
	next i
	
	if lVerSinPointCount=3 then
		lRet = 1							
		goto EndsetVerMotPathFlag
	else
		lRet = -1
		print "Not all of the single path points are set!"
	end if
  end if
 '******************************判断双组路径点位是否设置完成**********************************************************
  if pathType=2 then
	for k =1 to 5
		if isPointValue(glVerDouTemp[k])<>1 then
			lVerDouPointCount=lVerDouPointCount+1
		end if
	next k
	
	if lVerDouPointCount=5 then
		lRet=2
		goto EndsetVerMotPathFlag
	else
		lRet=-1
		print "Not all of the double path points are set!"
	end if
  end if
  
  EndsetVerMotPathFlag:
	if lRet <> -1 then
		TotalVerPltArray[TotalVerArrayIndex]->lVerPltMotFlag=lRet	
		lFuncRet = 0					
	else 
	    lFuncRet = -1
		print "Not all of the points are set!"
	end if
  setVerMotPathFlag=lFuncRet
end function

'***********************************************************************************************************************
' function Name: getVerMotPathFlag
' Description: 获取垂直码垛路径选择的标志位
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    lVerPltMotFlag=路径类型值，1-代表单组，2-代表双组
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function getVerMotPathFlag(byval TotalVerArrayIndex as long)as long
   getVerMotPathFlag=TotalVerPltArray[TotalVerArrayIndex]->lVerPltMotFlag
end function

'***********************************************************************************************************************
' function Name:  HorPltCalibrateBase
' Description: 水平码垛坐标系标定（内标），根据多排码垛的排数自动标定每排的workpiece
'              参考http://softmc.servotronix.com/wiki/User_Frame
' Author:   Demean
' Input Parameters:  long
'                    TotalArrayIndex-为通道索引，索引从1开始，上限值为6
'                    RowCount-为码垛的排数，最小1，上限值为6
' Output Parameters: generic location
'                    glTempCalFrame-标定的坐标系                     
' Return Value: long:
'               0 -success
'               Not 0 - Calibratedworkpiece is Failed
' Algorithm:
' Global Variables Used:
' Revisions:
'***********************************************************************************************************************

public function HorPltCalibrateBase( byval TotalArrayIndex as long, byval RowCount as long) as long
   dim lRet as long = -1
   dim i as long = 1
   dim lInvalidFrame as long = -1
   dim glPointA as generic location
   dim glPointB as generic location
   dim glPointC as generic location
   dim glTempCalFrame as generic location
   
   for i=1 to RowCount
     glPointA=TotalPltArray[TotalArrayIndex]->glStartPoint[i]
     glPointB=TotalPltArray[TotalArrayIndex]->glTermPoint[i]
     
     '***********将起始点沿x负方向偏移一定距离后赋值给参与点，参与坐标系标定*******************************
	if glPointA{1} < glPointB{1} and 1 < abs(glPointA{1}-glPointB{1}) then
		'*****************起始点到终止点有向线段指向X轴正半轴但不与X轴和Y轴平行****************************
		TotalPltArray[TotalArrayIndex]->glPartPoint[i]=glPointA
		
	    '********************计算点在起始点基础上y坐标值增加**********************************************
		TotalPltArray[TotalArrayIndex]->glPartPoint[i]{2}=TotalPltArray[TotalArrayIndex]->glPartPoint[i]{2}+abs(glPointB{1}-glPointA{1}) 
	end if

	if glPointA{1} < glPointB{1} and 0.0001 < abs(glPointA{2}-glPointB{2}) < 1 then
		'*****************起始点到终止点有向线段指向X轴正半轴且平行于X轴**********************************	 
		TotalPltArray[TotalArrayIndex]->glPartPoint[i]=glPointA

		'******************************计算点在起始点基础上y坐标值增加************************************
		TotalPltArray[TotalArrayIndex]->glPartPoint[i]{2}=TotalPltArray[TotalArrayIndex]->glPartPoint[i]{2}+abs(glPointB{1}-glPointA{1}) 
	end if
	
	if glPointA{2} < glPointB{2} and 0.0001 < abs(glPointA{1}-glPointB{1})<1  then
		'********************起始点到终止点有向线段指向Y轴正半轴且平行于Y轴*******************************	 
		TotalPltArray[TotalArrayIndex]->glPartPoint[i]=glPointA
		
		'***********************计算点在起始点基础上X坐标值减少*******************************************
		TotalPltArray[TotalArrayIndex]->glPartPoint[i]{1}=TotalPltArray[TotalArrayIndex]->glPartPoint[i]{1}-abs(glPointB{2}-glPointA{2}) 	 
	end if 
	
	if glPointA{1} > glPointB{1} and 1 < abs(glPointA{2}-glPointB{2})  then
		'********************起始点到终止点有向线段指向X轴负半轴且不平行于X轴和Y轴*************************	
		TotalPltArray[TotalArrayIndex]->glPartPoint[i]=glPointA
	
	    '***********************计算点在起始点基础上X坐标值减少********************************************
		TotalPltArray[TotalArrayIndex]->glPartPoint[i]{1}=TotalPltArray[TotalArrayIndex]->glPartPoint[i]{1}+abs(glPointB{2}-glPointA{2})  	   
	
	end if
				
	if glPointA{1} > glPointB{1} and 0.0001 < abs(glPointA{2}-glPointB{2})< 1 then
		'************************起始点到终止点有向线段指向X轴负半轴且平行于X轴****************************
	    TotalPltArray[TotalArrayIndex]->glPartPoint[i]=glPointA
	
		'***********************计算点在起始点基础上Y坐标值减少********************************************
		TotalPltArray[TotalArrayIndex]->glPartPoint[i]{2}=TotalPltArray[TotalArrayIndex]->glPartPoint[i]{2}+abs(glPointB{1}-glPointA{1})
	end if
	
	if glPointA{2} > glPointB{2} and 0.0001 < abs(glPointA{1}-glPointB{1})<1 then 
		'************************起始点到终止点有向线段指向Y轴负半轴且平行于y轴****************************
	    TotalPltArray[TotalArrayIndex]->glPartPoint[i]=glPointA
	
		'***********************计算点在起始点基础上X坐标值增加********************************************
		TotalPltArray[TotalArrayIndex]->glPartPoint[i]{1}=TotalPltArray[TotalArrayIndex]->glPartPoint[i]{1}+abs(glPointB{2}-glPointA{2})
	end if
				
	glPointC=TotalPltArray[TotalArrayIndex]->glPartPoint[i]
	
	lRet=RBT_TABLE(glPointA,glPointB,glPointC,glTempCalFrame)
	
	if lRet=0 then
		TotalPltArray[TotalArrayIndex]->glCalibratedFrame[i]=glTempCalFrame
		print "TotalPltArray[TotalArrayIndex]->glCalibratedFrame[#]:"TotalArrayIndex,i,glTempCalFrame
	else
		lRet=lInvalidFrame
	end if
   next i   
   HorPltCalibrateBase=lRet
end function

'***********************************************************************************************************************
' function Name:  VerPltCalibrateBase
' Description: 垂直码垛坐标系标定  参考http://softmc.servotronix.com/wiki/User_Frame             
' Author:   Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: generic location
'                    glTempCalFrame-标定的坐标系                     
' Return Value: long:
'               0 -success
'               Not 0 - Calibratedworkpiece is Failed
' Algorithm:
' Global Variables Used:
' Revisions:
'***********************************************************************************************************************

public function VerPltCalibrateBase( byval TotalVerArrayIndex as long) as long
   dim lRet as long = -1
   dim lInvalidFrame as long= -1
   dim glPointA as generic location
   dim glPointB as generic location
   dim glPointC as generic location
   dim glTempCalFrame as generic location
   
   glPointA=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne
   glPointB=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointTwo
   glPointC=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointThree
   
   lRet=RBT_TABLE(glPointA,glPointB,glPointC,glTempCalFrame)
   if lRet=0 then
     TotalVerPltArray[TotalVerArrayIndex]->glVerCalibratedFrame=glTempCalFrame
     print "TotalVerPltArray[TotalVerArrayIndex]->glVerCalibratedFrame:"TotalVerArrayIndex,glTempCalFrame
   else
       lRet=lInvalidFrame
   end if   
   VerPltCalibrateBase=lRet
end function

'***********************************************************************************************************************
' sub Name:  LmJump
' Description: 龙门跳运动,分为4轴和6轴             
' Author:   Demean
' Input Parameters:  long
'                    TotalArrayIndex-为通道索引，索引从1开始，上限值为6
'                    isMove-为运动状态，1-运动，0-没有运动
'                    MotType-为运动类型，1-Move运动，0-Moves运动
'                    BlendingFactValue-圆滑过渡百分比，最小90，最大100
' Output Parameters: None                   
' Return Value: long:
' Algorithm:
' Global Variables Used:
' Revisions:
'***********************************************************************************************************************

public sub LmJump(byval TotalArrayIndex as long, byval isMove as long, byval MotType as long, byval D_outNum as long, byval BlendingFactValue as double)

   '******************************用来保存当前正在使用BlendingMethod值**************************************************
   dim CurBlendingMethod as long
   
   lCurRowNum=JudgeCurWorkPiece(TotalArrayIndex)
   if lCurRowNum <> 0 and lCurRowNum<> -1 then
      glTempCoordinate=workpiece
	  while robot.isMoving 
		sleep 10
	  end while
      workpiece = TotalPltArray[TotalArrayIndex]->glCalibratedFrame[lCurRowNum]
   end if

   CurBlendingMethod = robot.blendingMethod  
   '******************************************设置圆滑过渡类型为sp*****************************************************
   Delay Robot 10
   sleep 10
   robot.BlendingMethod = 2
   sleep 10
   '**********************************将BlendingFactor值限制在90-100之间，保证过渡效果*********************************
   if BlendingFactValue < 90 then
      BlendingFactValue = 100
   end if
   
   if isMove =1 then
     select case TotalPltArray[TotalArrayIndex]->lStackType
     case 1   '*************码垛*******************************************************************************************
       if robot.ElementSize = 4 then    '4轴机型码垛运动顺序：码垛点上方->码垛点->回退点->回到取料点
	     select case MotType
		   case 0
			    Print "glLMJumpTopPoint:"glLMJumpTopPoint                  
			    Moves ROBOT glLMJumpTopPoint  Blendingfactor=BlendingFactValue       '4轴机型码垛时为实际码垛点的最上方的点
			   
			    Print "glActualPltPoint:"glActualPltPoint                  
			    Moves ROBOT glActualPltPoint                                         '4轴机型码垛时的实际的码垛点
			    Delay 10
			    if D_OUT[D_outNum]=OFF then
				   D_OUT[D_outNum]=ON
			    else
				   D_OUT[D_outNum]=OFF 
			    end if
	   
			    Print "glLMJumpActualTransPoint:"glLMJumpActualTransPoint  
			    Moves ROBOT glLMJumpActualTransPoint  Blendingfactor=BlendingFactValue '4轴机型码垛时的实际的过渡点（回退点）    
		   case 1
			    Print "glLMJumpTopPoint:"glLMJumpTopPoint                  
			    Move ROBOT glLMJumpTopPoint  Blendingfactor=BlendingFactValue          '4轴机型码垛时为实际码垛点的最上方的点
			   
			    Print "glActualPltPoint:"glActualPltPoint                  
			    Move ROBOT glActualPltPoint                                            '4轴机型码垛时的实际的码垛点
			    Delay 10
			    if D_OUT[D_outNum]=OFF then
				   D_OUT[D_outNum]=ON
			    else
				   D_OUT[D_outNum]=OFF 
			    end if
	   
			    Print "glLMJumpActualTransPoint:"glLMJumpActualTransPoint  
			    Move ROBOT glLMJumpActualTransPoint  Blendingfactor=BlendingFactValue   '4轴机型码垛时的实际的过渡点（回退点） 		   
		 end select  
       end if
	   
       if robot.ElementSize = 6 then    '6轴机型码垛运动运动顺序：码垛点上方->码垛点->回退点->回到取料点
		 select case MotType
		   case 0   '*************MOVES运动**********************************************************
				 Print "glLMJumpTopPoint:"glLMJumpTopPoint                  
				 Moves ROBOT glLMJumpTopPoint  Blendingfactor=BlendingFactValue         '6轴机型码垛时为实际码垛点的最上方的点

				 Print "glActualPltPoint:"glActualPltPoint                  
				 Moves ROBOT glActualPltPoint                                           '6轴机型码垛时的实际的码垛点
				 
				 Delay 10
		         if D_OUT[D_outNum]=OFF then
		            D_OUT[D_outNum]=ON
		         else
		            D_OUT[D_outNum]=OFF 
		         end if
				 Print "glLMJumpActualTransPoint:"glLMJumpActualTransPoint  
				 Moves ROBOT glLMJumpActualTransPoint  Blendingfactor=BlendingFactValue  '6轴机型码垛时的实际过渡点（回退点）
						   
		   case 1   '*************MOVE运动**********************************************************
				 Print "glLMJumpTopPoint:"glLMJumpTopPoint                  
				 Move ROBOT glLMJumpTopPoint  Blendingfactor=BlendingFactValue           '6轴机型码垛时为实际码垛点的最上方的点

				 Print "glActualPltPoint:"glActualPltPoint                  
				 Move ROBOT glActualPltPoint                                             '6轴机型码垛时的实际的码垛点
				 Delay 10
		         if D_OUT[D_outNum]=OFF then
		            D_OUT[D_outNum]=ON
		         else
		            D_OUT[D_outNum]=OFF 
		         end if				 
				 
				 Print "glLMJumpActualTransPoint:"glLMJumpActualTransPoint  
				 Move ROBOT glLMJumpActualTransPoint  Blendingfactor=BlendingFactValue   '6轴机型码垛时的实际过渡点（回退点）                    
		 end select     
		end if
     case 2  '*************拆垛*******************************************************************************************
       if robot.ElementSize = 4 then    '4轴机型拆垛运动顺序：趋近点->拆垛点->运动到上方点->回到放料点
	     select case MotType
		   case 0
			    Print "glLMJumpActualTransPoint:"glLMJumpActualTransPoint  
			    Moves ROBOT glLMJumpActualTransPoint  Blendingfactor=BlendingFactValue   '4轴机型码垛时的实际的过渡点（趋近点)
			   
			    Print "glActualPltPoint:"glActualPltPoint                  
			    Moves ROBOT glActualPltPoint                                             '4轴机型码垛时的实际的拆垛点
			    Delay 10
			    if D_OUT[D_outNum]=OFF then
				   D_OUT[D_outNum]=ON
			    else
				   D_OUT[D_outNum]=OFF 
			    end if		   
			    Print "glLMJumpTopPoint:"glLMJumpTopPoint                  
			    Moves ROBOT glLMJumpTopPoint  Blendingfactor=BlendingFactValue           '4轴机型码垛时为实际拆垛点的最上方的点		   
		   case 1
			    Print "glLMJumpActualTransPoint:"glLMJumpActualTransPoint  
			    Move ROBOT glLMJumpActualTransPoint  Blendingfactor=BlendingFactValue    '4轴机型码垛时的实际的过渡点（趋近点)
			   
			    Print "glActualPltPoint:"glActualPltPoint                  
			    Move ROBOT glActualPltPoint                                              '4轴机型码垛时的实际的拆垛点
			    Delay 10
			    if D_OUT[D_outNum]=OFF then
				   D_OUT[D_outNum]=ON
			    else
				   D_OUT[D_outNum]=OFF 
			    end if		   
			    Print "glLMJumpTopPoint:"glLMJumpTopPoint                  
			    Move ROBOT glLMJumpTopPoint  Blendingfactor=BlendingFactValue            '4轴机型码垛时为实际拆垛点的最上方的点		   
		 end select
     end if 
	 
     if robot.ElementSize = 6 then    '6轴机型拆垛运动运动顺序：趋近点->拆垛点->拆垛点上方->回到放料点
        select case MotType
		  case 0  '*************MOVES运动**********************************************************
			 Print "glLMJumpActualTransPoint:"glLMJumpActualTransPoint  
			 Moves ROBOT glLMJumpActualTransPoint  Blendingfactor=BlendingFactValue      '6轴机型码垛时的实际趋近点
			 
			 Print "glActualPltPoint:"glActualPltPoint                  
			 Moves ROBOT glActualPltPoint                                                '6轴机型码垛时的实际的拆垛点
			 Delay 10
			 if D_OUT[D_outNum]=OFF then
				D_OUT[D_outNum]=ON
			 else
				D_OUT[D_outNum]=OFF 
			 end if			 
			 Print "glLMJumpTopPoint:"glLMJumpTopPoint                  
			 Moves ROBOT glLMJumpTopPoint  Blendingfactor=BlendingFactValue              '6轴机型码垛时为实际拆垛点的最上方的点
		  case 1  '*************MOVE运动**********************************************************
			 Print "glLMJumpActualTransPoint:"glLMJumpActualTransPoint  
			 Move ROBOT glLMJumpActualTransPoint  Blendingfactor=BlendingFactValue       '6轴机型码垛时的实际趋近点
			 
			 Print "glActualPltPoint:"glActualPltPoint                  
			 Move ROBOT glActualPltPoint                                                 '6轴机型码垛时的实际的拆垛点
			 Delay 10
			 if D_OUT[D_outNum]=OFF then
				D_OUT[D_outNum]=ON
			 else
				D_OUT[D_outNum]=OFF 
			 end if			 
			 Print "glLMJumpTopPoint:"glLMJumpTopPoint                  
			 Move ROBOT glLMJumpTopPoint  Blendingfactor=BlendingFactValue               '6轴机型码垛时为实际拆垛点的最上方的点      
        end select
     end if
     end select  
   end if
   '*******************************************************************************************************************
   call WorkpieceNumPlus(1,TotalArrayIndex,TotalPltArray[TotalArrayIndex]-> lStackType)
   delay 10
   workpiece=glTempCoordinate
   '********************************************还原BlendingMethod值***************************************************   
   Delay Robot 10
   sleep 10
   robot.blendingMethod = CurBlendingMethod       
   sleep 10
end sub

'***********************************************************************************************************************
' sub Name:  AppPlt
' Description: 趋近点运动             
' Author:   Demean
' Input Parameters:  long
'                    TotalArrayIndex-为通道索引，索引从1开始，上限值为6
'                    isMove-为运动状态，1-运动，0-没有运动
'                    OneMotType-为趋近点1运动类型，1-Move运动，0-Moves运动
'                    TwoMotType-为趋近点2运动类型，1-Move运动，0-Moves运动
'                    BlendingFactValue-圆滑过渡百分比，最小90，最大100
' Output Parameters: None                   
' Return Value: long:
' Algorithm:
' Global Variables Used:
' Revisions:
'***********************************************************************************************************************

public sub AppPlt(byval TotalArrayIndex as long, byval isMove as long, byval OneMotType as long,byval TwoMotType as long,byval BlendingFactValue as double)
  
  '******************************用来保存当前正在使用BlendingMethod值***************************************************
   dim CurBlendingMethod as long     
   
   lCurRowNum=JudgeCurWorkPiece(TotalArrayIndex)
   if lCurRowNum <> 0 and lCurRowNum<> -1 then
      glTempCoordinate=workpiece
	  while robot.isMoving 
	    sleep 10
	  end while
      workpiece = TotalPltArray[TotalArrayIndex]->glCalibratedFrame[lCurRowNum]
   end if
   '****************************************获取当前BlendingMethod值***************************************************
   CurBlendingMethod = robot.blendingMethod  
   '******************************************设置圆滑过渡类型为sp*****************************************************
   Delay Robot 10
   sleep 10
   robot.BlendingMethod = 2
   sleep 10
   '**********************************将BlendingFactor值限制在90-100之间，保证过渡效果*********************************
   if BlendingFactValue < 90 then
      BlendingFactValue = 100
   end if
   
   if isMove =1 then
	   select case  TotalPltArray[TotalArrayIndex]-> lHorPltMotFlag
		
		case 1  '*************单组路径运动*******************************************************************************
		   select case OneMotType
			 case 0  '*************Moves运动***************************************************************************
			  Print "glSinActualAppPoint:"glSinActualAppPoint
			  Moves ROBOT glSinActualAppPoint  Blendingfactor=BlendingFactValue
			 case 1  '*************Move运动****************************************************************************
			  Print "glSinActualAppPoint:"glSinActualAppPoint  Blendingfactor=BlendingFactValue
			  Move ROBOT glSinActualAppPoint
		   end select 
		   
		case 2  '*************双组路径运动，趋近运动顺序：趋近点2->趋近点1***********************************************
		
		   '*************双组运动路径趋近点2的运动类型*****************************************************************       
		   select case TwoMotType
			 case 0  '*************Moves运动***************************************************************************
			  Print "glDouActualAppPoint[2]:"glDouActualAppPoint[2]
			  Moves ROBOT glDouActualAppPoint[2]  Blendingfactor=BlendingFactValue
			 case 1  '*************Move运动****************************************************************************
			  Print "glDouActualAppPoint[2]:"glDouActualAppPoint[2]
			  Move ROBOT glDouActualAppPoint[2]  Blendingfactor=BlendingFactValue
		   end select 
		   
		   '*************双组运动路径趋近点1的运动类型*****************************************************************
		   select case OneMotType   
			 case 0  '*************Moves运动***************************************************************************
			  Print "glDouActualAppPoint[1]:"glDouActualAppPoint[1]
			  Moves ROBOT glDouActualAppPoint[1] Blendingfactor=BlendingFactValue
			 case 1  '*************Move运动****************************************************************************
			  Print "glDouActualAppPoint[1]:"glDouActualAppPoint[1]
			  Move ROBOT glDouActualAppPoint[1]  Blendingfactor=BlendingFactValue
		   end select               
	   end select   
   end if
   
   '********************************************还原BlendingMethod值***************************************************
   Delay Robot 10  
   sleep 10       
   robot.blendingMethod = CurBlendingMethod 
   sleep 10
   workpiece = glTempCoordinate
end sub

'***********************************************************************************************************************
' sub Name:  VAppPlt
' Description: 垂直码垛趋近点运动             
' Author:   Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    isMove-为运动状态，1-运动，0-没有运动
'                    OneMotType-为趋近点1运动类型，1-Move运动，0-Moves运动
'                    TwoMotType-为趋近点2运动类型，1-Move运动，0-Moves运动
'                    BlendingFactValue-圆滑过渡百分比，最小90，最大100
' Output Parameters: None                   
' Return Value: long:
' Algorithm:
' Global Variables Used:
' Revisions:
'*********************************************************************************************************************** 

public sub VAppPlt(byval TotalVerArrayIndex as long, byval isMove as long, byval OneMotType as long,byval TwoMotType as long,byval BlendingFactValue as double)

  '******************************用来保存当前正在使用BlendingMethod值***************************************************
   dim CurBlendingMethod as long   

  if TotalVerPltArray[TotalVerArrayIndex]->lVerToolFrameNum = 0 then 
     Tool = Tool_Frame_original
  else
     Tool=Tool_Frame[TotalVerPltArray[TotalVerArrayIndex]->lVerToolFrameNum]  
  end if
  glTempVerCoordinate=workpiece
  while robot.isMoving 
	sleep 10
  end while  
  workpiece=TotalVerPltArray[TotalVerArrayIndex]->glVerCalibratedFrame
  '******************************************获取当前BlendingMethod值***************************************************
  CurBlendingMethod = robot.blendingMethod  
  '********************************************设置圆滑过渡类型为sp*****************************************************
  Delay Robot 10  
  sleep 10 
  BlendingMethod = 2  
  sleep 10
  '**********************************将BlendingFactor值限制在90-100之间，保证过渡效果*********************************
  if BlendingFactValue < 90 then
     BlendingFactValue = 100
  end if
   
  if isMove=1 then
    select case TotalVerPltArray[TotalVerArrayIndex]->lVerPltMotFlag
	  case 1   '*************单组路径运动*******************************************************************************
	       select case OneMotType
		     case 0   '*************Moves运动***************************************************************************
				  Print "glVerSinActualAppPoint:"glVerSinActualAppPoint
				  Moves ROBOT glVerSinActualAppPoint Blendingfactor=BlendingFactValue
			 case 1   '*************Move运动****************************************************************************
				  Print "glVerSinActualAppPoint:"glVerSinActualAppPoint
				  Move ROBOT glVerSinActualAppPoint	 Blendingfactor=BlendingFactValue		 
		    end select
	  case 2   '*************双组路径运动*******************************************************************************
	       select case TwoMotType
		     case 0   '*************Moves运动***************************************************************************
				  Print "glVerDouActualAppPoint[2]:"glVerDouActualAppPoint[2]
				  Moves ROBOT glVerDouActualAppPoint[2]	Blendingfactor=BlendingFactValue		 
			 case 1   '**************Move运动***************************************************************************
				  Print "glVerDouActualAppPoint[2]:"glVerDouActualAppPoint[2]
				  Move ROBOT glVerDouActualAppPoint[2]	Blendingfactor=BlendingFactValue		 
			end select
	       select case OneMotType
		     case 0   '*************Moves运动***************************************************************************
				  Print "glVerDouActualAppPoint[1]:"glVerDouActualAppPoint[1]
				  Moves ROBOT glVerDouActualAppPoint[1] Blendingfactor=BlendingFactValue
			 case 1   '**************Move运动***************************************************************************
				  Print "glVerDouActualAppPoint[1]:"glVerDouActualAppPoint[1]
				  Move ROBOT glVerDouActualAppPoint[1]	Blendingfactor=BlendingFactValue			 
			end select			
	end select
  end if
  delay 10
  workpiece=glTempVerCoordinate
  '********************************************还原BlendingMethod值*****************************************************
  Delay Robot 10  
  sleep 10   
  robot.blendingMethod = CurBlendingMethod    
  sleep 10
end sub
'***********************************************************************************************************************
' sub Name:  BackPlt
' Description: 趋近点运动             
' Author:   Demean
' Input Parameters:  long
'                    TotalArrayIndex-为通道索引，索引从1开始，上限值为6
'                    isMove-为运动状态，1-运动，0-没有运动
'                    OneMotType-为回退点1运动类型，1-Move运动，0-Moves运动
'                    TwoMotType-为回退点2运动类型，1-Move运动，0-Moves运动
'                    BlendingFactValue-圆滑过渡百分比，最小90，最大100
' Output Parameters: None                   
' Return Value: long:
' Algorithm:
' Global Variables Used:
' Revisions:
'*********************************************************************************************************************** 

public sub BackPlt(byval TotalArrayIndex as long, byval isMove as long, byval OneMotType as long,byval TwoMotType as long,byval BlendingFactValue as double)
 
   '******************************用来保存当前正在使用BlendingMethod值***************************************************
   dim CurBlendingMethod as long 
   
   lCurRowNum=JudgeCurWorkPiece(TotalArrayIndex)
   if lCurRowNum <> 0 and lCurRowNum<> -1 then
      glTempCoordinate=workpiece
	  while robot.isMoving 
	    sleep 10
	  end while	  
      workpiece = TotalPltArray[TotalArrayIndex]->glCalibratedFrame[lCurRowNum]
   end if
   
  '******************************************获取当前BlendingMethod值***************************************************
  CurBlendingMethod = robot.blendingMethod  
  '********************************************设置圆滑过渡类型为sp*****************************************************
  Delay Robot 10  
  sleep 10 
  robot.BlendingMethod = 2  
  sleep 10
  '**********************************将BlendingFactor值限制在90-100之间，保证过渡效果***********************************
  if BlendingFactValue < 90 then
     BlendingFactValue = 100
  end if
  
   if isMove =1 then
     select case TotalPltArray[TotalArrayIndex]-> lHorPltMotFlag
        case 1  '*************单组路径运动*******************************************************************************
             select case OneMotType
			   case 0  '*************Moves运动***************************************************************************
				  Print "glSinActualBackPoint:"glSinActualBackPoint
				  Moves ROBOT glSinActualBackPoint Blendingfactor=BlendingFactValue
               case 1  '*************Move运动****************************************************************************
				  Print "glSinActualBackPoint:"glSinActualBackPoint
				  Move ROBOT glSinActualBackPoint  Blendingfactor=BlendingFactValue
             end select 
        case 2  '*************双组路径运动，回退运动顺序：趋近点1->趋近点2***********************************************
		     select case OneMotType
			   case 0  '*************Moves运动***************************************************************************
			      Print "glDouActualBackPoint[1]:"glDouActualBackPoint[1]
			      Moves ROBOT glDouActualBackPoint[1] Blendingfactor=BlendingFactValue
			   case 1  '*************Move运动****************************************************************************
			      Print "glDouActualBackPoint[1]:"glDouActualBackPoint[1]
			      Move ROBOT glDouActualBackPoint[1] Blendingfactor=BlendingFactValue
		     end select
		 
			 select case TwoMotType
			   case 0  '*************Moves运动***************************************************************************
			      Print "glDouActualBackPoint[2]:"glDouActualBackPoint[2]
			      Moves ROBOT glDouActualBackPoint[2] Blendingfactor=BlendingFactValue
			   case 1  '*************Move运动****************************************************************************
			      Print "glDouActualBackPoint[2]:"glDouActualBackPoint[2]
			      Move ROBOT glDouActualBackPoint[2] Blendingfactor=BlendingFactValue
			 end select     
     end select    
   end if
   call WorkpieceNumPlus(1,TotalArrayIndex,TotalPltArray[TotalArrayIndex]-> lStackType)
   delay 10
   workpiece = glTempCoordinate
   '********************************************还原BlendingMethod值***************************************************** 
   Delay Robot 10    
   sleep 10 
   robot.blendingMethod = CurBlendingMethod       
   sleep 10
end sub

'***********************************************************************************************************************
' sub Name:  VBackPlt
' Description: 垂直码垛回退点运动             
' Author:   Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    isMove-为运动状态，1-运动，0-没有运动
'                    OneMotType-为趋近点1运动类型，1-Move运动，0-Moves运动
'                    TwoMotType-为趋近点2运动类型，1-Move运动，0-Moves运动
'                    BlendingFactValue-圆滑过渡百分比，最小90，最大100
' Output Parameters: None                   
' Return Value: long:
' Algorithm:
' Global Variables Used:
' Revisions:
'***********************************************************************************************************************

public sub VBackPlt(byval TotalVerArrayIndex as long, byval isMove as long, byval OneMotType as long,byval TwoMotType as long,byval BlendingFactValue as double)

  '******************************用来保存当前正在使用BlendingMethod值***************************************************
  dim CurBlendingMethod as long 
  
  if TotalVerPltArray[TotalVerArrayIndex]->lVerToolFrameNum = 0 then 
     Tool = Tool_Frame_original
  else
     Tool=Tool_Frame[TotalVerPltArray[TotalVerArrayIndex]->lVerToolFrameNum]  
  end if

  glTempVerCoordinate=workpiece
  while robot.isMoving 
	sleep 10
  end while  
  workpiece=TotalVerPltArray[TotalVerArrayIndex]->glVerCalibratedFrame
  
  '******************************************获取当前BlendingMethod值***************************************************
  CurBlendingMethod = robot.blendingMethod  
  '********************************************设置圆滑过渡类型为sp*****************************************************
  Delay Robot 10
  sleep 10
  robot.BlendingMethod = 2  
  sleep 10
  '**********************************将BlendingFactor值限制在90-100之间，保证过渡效果***********************************
  if BlendingFactValue < 90 then
     BlendingFactValue = 100
  end if
  
   if isMove =1 then
	  select case TotalVerPltArray[TotalVerArrayIndex]-> lVerPltMotFlag
        case 1  '*************单组路径运动*******************************************************************************
		     select case OneMotType
		       case 0  '*************Moves运动***************************************************************************
				  Print "glVerSinActualBackPoint:"glVerSinActualBackPoint
				  Moves ROBOT glVerSinActualBackPoint Blendingfactor=BlendingFactValue
		       case 1  '*************Move运动****************************************************************************
				  Print "glVerSinActualBackPoint:"glVerSinActualBackPoint
				  Move ROBOT glVerSinActualBackPoint Blendingfactor=BlendingFactValue
		     end select 
        case 2  '*************双组路径运动，回退运动顺序：趋近点1->趋近点2***********************************************
			 select case OneMotType
			   case 0  '*************Moves运动***************************************************************************
				  Print "glVerDouActualBackPoint[1]:"glVerDouActualBackPoint[1]
				  Moves ROBOT glVerDouActualBackPoint[1] Blendingfactor=BlendingFactValue
			   case 1  '*************Move运动****************************************************************************
				  Print "glVerDouActualBackPoint[1]:"glVerDouActualBackPoint[1]
				  Move ROBOT glVerDouActualBackPoint[1] Blendingfactor=BlendingFactValue
			 end select
		 
		     select case TwoMotType
			   case 0  '*************Moves运动***************************************************************************
				  Print "glVerDouActualBackPoint[2]:"glVerDouActualBackPoint[2]
				  Moves ROBOT glVerDouActualBackPoint[2] Blendingfactor=BlendingFactValue
			   case 1  '*************Move运动****************************************************************************
				  Print "glVerDouActualBackPoint[2]:"glVerDouActualBackPoint[2]
				  Move ROBOT glVerDouActualBackPoint[2] Blendingfactor=BlendingFactValue
		     end select 		
       end select		
   end if
   call WorkpieceNumPlus(2,TotalVerArrayIndex,TotalVerPltArray[TotalVerArrayIndex]-> lVerStackType)
   delay 10
   workpiece = glTempVerCoordinate
   '********************************************还原BlendingMethod值***************************************************** 
   Delay Robot 10
   sleep 10  
   robot.blendingMethod = CurBlendingMethod     
   sleep 10
end sub

'***********************************************************************************************************************
' sub Name:  HorPlt
' Description: 码垛/拆垛点运动             
' Author:   Demean
' Input Parameters:  long
'                    TotalArrayIndex-为通道索引，索引从1开始，上限值为6
'                    isMove-为运动状态，1-运动，0-没有运动
'                    MotType-为运动类型，1-Move运动，0-Moves运动
'                    BlendingFactValue-圆滑过渡百分比，最小90，最大100
' Output Parameters: None                   
' Return Value: long:
' Algorithm:
' Global Variables Used:
' Revisions:
'***********************************************************************************************************************

public sub HorPlt(byval TotalArrayIndex as long, byval isMove as long, byval MotType as long)
   '******************************用来保存当前正在使用BlendingMethod值**************************************************
   ' dim CurBlendingMethod as long
   
   lCurRowNum=JudgeCurWorkPiece(TotalArrayIndex)
   if lCurRowNum <> 0 and lCurRowNum<> -1 then
      glTempCoordinate=workpiece
	  while robot.isMoving 
	    sleep 10
	  end while	  
      workpiece = TotalPltArray[TotalArrayIndex]->glCalibratedFrame[lCurRowNum]
   end if
 
   '******************************************获取当前BlendingMethod值***************************************************
   ' CurBlendingMethod = robot.blendingMethod  
   '********************************************设置圆滑过渡类型为sp*****************************************************
   ' BlendingMethod = 2  
   '**********************************将BlendingFactor值限制在90-100之间，保证过渡效果***********************************
   ' if BlendingFactValue < 90 then
   '	  BlendingFactValue = 100
   ' end if
   
   if isMove =1 then
     select case MotType
       case 0   '*******************Moves运动***************************************************************************
          Print "glActualPltPoint:"glActualPltPoint
          Moves ROBOT glActualPltPoint 
       case 1   '********************Move运动***************************************************************************
          Print "glActualPltPoint:"glActualPltPoint
          Move ROBOT glActualPltPoint 
     end select      
   end if
   delay 10
   workpiece = glTempCoordinate
   '********************************************还原BlendingMethod值*****************************************************
   ' while Robot.isMoving
   '  sleep 100
   ' end while
   ' sleep 100
   
   ' robot.blendingMethod = CurBlendingMethod    
end sub

'***********************************************************************************************************************
' sub Name:  VerPlt
' Description: 垂直码垛/拆垛点运动             
' Author:   Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
'                    isMove-为运动状态，1-运动，0-没有运动
'                    MotType-为运动类型，1-Move运动，0-Moves运动
'                    BlendingFactValue-圆滑过渡百分比，最小90，最大100
' Output Parameters: None                   
' Return Value: long:
' Algorithm:
' Global Variables Used:
' Revisions:
'***********************************************************************************************************************

public sub VerPlt(byval TotalVerArrayIndex as long, byval isMove as long, byval MotType as long)

   '******************************用来保存当前正在使用BlendingMethod值**************************************************
   ' dim CurBlendingMethod as long
   
   if TotalVerPltArray[TotalVerArrayIndex]->lVerToolFrameNum = 0 then 
     Tool = Tool_Frame_original
   else
     Tool=Tool_Frame[TotalVerPltArray[TotalVerArrayIndex]->lVerToolFrameNum]  
   end if
   glTempVerCoordinate=workpiece
   while robot.isMoving 
	 sleep 10
   end while
   workpiece = TotalVerPltArray[TotalVerArrayIndex]->glVerCalibratedFrame

   '******************************************获取当前BlendingMethod值***************************************************
   ' CurBlendingMethod = robot.blendingMethod  
   '********************************************设置圆滑过渡类型为sp*****************************************************
   ' BlendingMethod = 2  
   '**********************************将BlendingFactor值限制在90-100之间，保证过渡效果***********************************
   ' if BlendingFactValue < 90 then
	  ' BlendingFactValue = 100
   ' end if
   
   if isMove =1 then
     select case TotalVerPltArray[TotalVerArrayIndex]->lVerStackType
	   case 1   '************************************码垛***************************************************************
		  select case MotType
			case 0   '*******************Moves运动**********************************************************************
				  Print "glVerActualPltPoint:"glVerActualPltPoint
				  Moves ROBOT glVerActualPltPoint 
			case 1   '********************Move运动**********************************************************************
				  Print "glVerActualPltPoint:"glVerActualPltPoint
				  Move ROBOT glVerActualPltPoint 
		  end select 	      
	   case 2   '************************************拆垛***************************************************************
		  select case MotType
			case 0   '*******************Moves运动**********************************************************************
				  Print "glVerActualDepltPoint:"glVerActualDepltPoint
				  Moves ROBOT glVerActualDepltPoint 
			case 1   '********************Move运动**********************************************************************
				  Print "glVerActualDePltPoint:"glVerActualDepltPoint
				  Move ROBOT glVerActualDepltPoint 
		  end select 	   
	 end select
     
   end if  
   delay 10
   workpiece = glTempVerCoordinate
   '********************************************还原BlendingMethod值*****************************************************  
   ' while Robot.isMoving
    ' sleep 100
   ' end while
   ' sleep 100
   
   ' robot.blendingMethod = CurBlendingMethod     
end sub

'***********************************************************************************************************************
' sub Name:  calcHorPlt
' Description: 计算码垛/拆垛点、回退点和趋近点             
' Author:   Demean
' Input Parameters:  long
'                    TotalArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: None                   
' Return Value: long:
' Algorithm:  计算前需要将默认坐标系下示教得到的参考点位进行坐标变换，计算完成后再转换回去
' Global Variables Used:
' Revisions:
'***********************************************************************************************************************

public sub calcHorPlt(byval TotalArrayIndex as long) 
   dim XGap as Double
   dim YGap as Double
   dim ZGap as Double
   dim glTemp as generic location
   dim i as long
   
   '*************根据码垛类型和当前工件数判断工件所在的排的序号，用于码垛点、趋近点和回退点的计算***********************
   lCurRowNum=JudgeCurWorkPiece(TotalArrayIndex)
   
   '*************将在通用坐标系下的示教得到点转换为标定坐标下的点参与码垛点、趋近点和回退点的计算***********************
   if lCurRowNum <> 0 and lCurRowNum<> -1 then
      call PworldToPwp(TotalArrayIndex,lCurRowNum)
   end if   
     
   '********************根据工件所在排的起始点、终止点和工件数计算每个码垛点的X间距*************************************
   glCalcLoc=TotalPltArray[TotalArrayIndex]->glStartPoint[lCurRowNum]
   XGap=TotalPltArray[TotalArrayIndex]->glTermPoint[lCurRowNum]{1}-TotalPltArray[TotalArrayIndex]->glStartPoint[lCurRowNum]{1}
   XGap=abs(XGap)
   XGap=XGap/(TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt-1)
   
   '********************根据工件所在排的起始点、终止点和工件数计算每个码垛点的Y间距*************************************
   YGap=TotalPltArray[TotalArrayIndex]->glTermPoint[lCurRowNum]{2}-TotalPltArray[TotalArrayIndex]->glStartPoint[lCurRowNum]{2}
   YGap=abs(YGap)
   YGap=YGap/(TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt-1)
   
   '********************根据工件所在排的起始点、终止点和工件数计算每个码垛点的Z间距*************************************
   ZGap=TotalPltArray[TotalArrayIndex]->glTermPoint[lCurRowNum]{3}-TotalPltArray[TotalArrayIndex]->glStartPoint[lCurRowNum]{3}
   ZGap=abs(ZGap)
   ZGap=ZGap/(TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt-1)   
   select case  TotalPltArray[TotalArrayIndex]->lStackType
 
       case 1  '*************码垛***************************************************************************************
     
		  '********************根据当前码垛工件编号计算出实际码垛点*****************************************************
		  glCalcLoc{1}=XGap*(lCalcWorkPieceNum-1)
		  glCalcLoc{1}=TotalPltArray[TotalArrayIndex]->glStartPoint[lCurRowNum]{1}+glCalcLoc{1}
		   
		  glCalcLoc{2}=YGap*(lCalcWorkPieceNum-1)
		  glCalcLoc{2}=TotalPltArray[TotalArrayIndex]->glStartPoint[lCurRowNum]{2}+glCalcLoc{2} 

		  glCalcLoc{3}=ZGap*(lCalcWorkPieceNum-1)
		  glCalcLoc{3}=TotalPltArray[TotalArrayIndex]->glStartPoint[lCurRowNum]{3}+glCalcLoc{3} 

		  '********************将计算出来的码垛点位赋值给实际码垛点坐标变量*********************************************
		  glActualPltPoint=glCalcLoc
		  '***************************判断计算出的实际码垛点是否可达****************************************************
          call JudgeLimit(TotalArrayIndex,glActualPltPoint)    

		  '************************************************************************************************************
			select case TotalPltArray[TotalArrayIndex]->lHorPltMotFlag  
			case 1  '*************单组路径运动*************************************************************************
			
			   '*************单组路径计算实际趋近点********************************************************************
			   '*********将趋近点、参考点、回退点的点位赋值给中间变量以便计算△值和Inverse*****************************
			   glOneLoc=TotalPltArray[TotalArrayIndex]->glSinApproachPoint
			   glTwoLoc=TotalPltArray[TotalArrayIndex]->glSinRefPoint
			   glThreeLoc=TotalPltArray[TotalArrayIndex]->glSinBackPoint
			   
			   '*************************根据参考点位求出Inverse值*****************************************************
			   glInverPT=Inverse(glTwoLoc) 
			   
			   '****************************根据趋近点位求出△值*******************************************************
			   glDeltaVal=glInverPT:glOneLoc
			   
			   '********************将计算出的点位赋值给实际趋近点位变量***********************************************
			   glSinActualAppPoint=glActualPltPoint:glDeltaVal
			  '***************************判断计算出的实际趋近点是否可达***********************************************
              call JudgeLimit(TotalArrayIndex,glSinActualAppPoint)       

			   '*****************************************************************************************************
			   
			   '*************单组路径计算实际回退点******************************************************************
			   '*************************根据参考点位求出Inverse值***************************************************
			   glInverPT=Inverse(glTwoLoc) 
			   
			   '****************************根据回退点位求出△值***************************************************** 
			   glDeltaVal=glInverPT:glThreeLoc
			   
			   '********************将计算出的点位赋值给实际回退点位变量*********************************************
			   glSinActualBackPoint=glActualPltPoint:glDeltaVal
			  '***************************判断计算出的实际回退点是否可达*********************************************
              call JudgeLimit(TotalArrayIndex,glSinActualBackPoint)     
			  '*****************************************************************************************************           

			case 2  '*************双组路径运动**********************************************************************
			
					   '*************双组路径计算实际趋近点和回退点*************************************************
			   '*********将趋近点、参考点、回退点的点位赋值给中间变量以便计算△值和Inverse**************************
			  for i = 1 to 2  
				 glOneLoc=TotalPltArray[TotalArrayIndex]->glDouApproachPoint[i]
				 glTwoLoc=TotalPltArray[TotalArrayIndex]->glDouRefPoint
				 glThreeLoc=TotalPltArray[TotalArrayIndex]->glDouBackPoint[i]
			  
				 '*************************根据参考点位求出Inverse值***********************************************
				 glInverPT=Inverse(glTwoLoc) 
				 
				 '****************************根据趋近点位求出△值************************************************* 
				 glDeltaVal=glInverPT:glOneLoc
				 
				 '********************将计算出的点位赋值给实际趋近点位变量*****************************************
				 glDouActualAppPoint[i]=glActualPltPoint:glDeltaVal
				'***************************判断计算出的实际趋近点是否可达*****************************************
              call JudgeLimit(TotalArrayIndex,glDouActualAppPoint[i])       

				 '*************************************************************************************************
				 
				 '*************************根据参考点位求出Inverse值***********************************************
				 glInverPT=Inverse(glTwoLoc) 
				 
				 '****************************根据回退点位求出△值************************************************* 
				 glDeltaVal=glInverPT:glThreeLoc
				 
				 '********************将计算出的点位赋值给实际回退点位变量*****************************************
				 glDouActualBackPoint[i]=glActualPltPoint:glDeltaVal
				'***************************判断计算出的实际回退点是否可达*****************************************
              call JudgeLimit(TotalArrayIndex,glDouActualBackPoint[i])       

				   '*************************************************************************************************   
			  next i 

			case 3  '*************龙门跳运动*************************************************************************
			   if robot.ElementSize = 4 then
			       lZmaxHeight=robot.j[3].pmax-5-TotalPltArray[TotalArrayIndex]->glCalibratedFrame[lCurRowNum]{3}
                   glOneLoc=glActualPltPoint				   
				   glOneLoc{3}= lZmaxHeight
				   glLMJumpTopPoint=glOneLoc
				   

				   '*************4轴机型龙门跳运动计算实际过渡点（回退点）*******************************************
				   '*************************根据参考点位求出Inverse值***********************************************
				   glTwoLoc=TotalPltArray[TotalArrayIndex]->glLmJumpRefPoint
				   glThreeLoc=TotalPltArray[TotalArrayIndex]->glLmJumpTransPoint
				 
				   glInverPT=Inverse(glTwoLoc) 
			   
				   '****************************根据回退点位求出△值************************************************* 
				   glDeltaVal=glInverPT:glThreeLoc
			   
				   '********************将计算出的点位赋值给实际回退点位变量*****************************************
				   glLMJumpActualTransPoint=glActualPltPoint:glDeltaVal  
				   '***************************判断计算出的实际过渡点是否可达****************************************
	              call JudgeLimit(TotalArrayIndex,glLMJumpActualTransPoint)    
				'************************************************************************************************			
			   end if
			   if robot.ElementSize = 6 then
				   glCalcLoc{3}=glCalcLoc{3}+TotalPltArray[TotalArrayIndex]->lLiftHeight
		
				   glLMJumpTopPoint=glCalcLoc                                                '6轴机型龙门跳运动上方点
				   
					'***************************判断计算出的实际龙门跳点是否可达*************************************
	              call JudgeLimit(TotalArrayIndex,glLMJumpTopPoint)       
					'************************************************************************************************             

				   '*************6轴机型龙门跳运动计算实际过渡点（回退点）*******************************************
				   '*************************根据参考点位求出Inverse值***********************************************
				   glTwoLoc=TotalPltArray[TotalArrayIndex]->glLmJumpRefPoint
				   glThreeLoc=TotalPltArray[TotalArrayIndex]->glLmJumpTransPoint
				 
				   glInverPT=Inverse(glTwoLoc) 
			   
				   '****************************根据回退点位求出△值************************************************* 
				   glDeltaVal=glInverPT:glThreeLoc
			   
				   '********************将计算出的点位赋值给实际回退点位变量*****************************************
				   glLMJumpActualTransPoint=glActualPltPoint:glDeltaVal  
				'***************************判断计算出的实际过渡点是否可达***************************************
	              call JudgeLimit(TotalArrayIndex,glLMJumpActualTransPoint)       
				'************************************************************************************************                           
			   end if
	   
			end select

      case 2    '*************拆垛***************************************************************************************  
      '********************根据当前拆垛工件编号计算出实际拆垛点****************************************************
      glCalcLoc{1}=XGap*(lCalcWorkPieceNum-1)
      glCalcLoc{1}=TotalPltArray[TotalArrayIndex]->glTermPoint[lCurRowNum]{1}-glCalcLoc{1}
       
      glCalcLoc{2}=YGap*(lCalcWorkPieceNum-1)
      glCalcLoc{2}=TotalPltArray[TotalArrayIndex]->glTermPoint[lCurRowNum]{2}-glCalcLoc{2} 

      glCalcLoc{3}=ZGap*(lCalcWorkPieceNum-1)
      glCalcLoc{3}=TotalPltArray[TotalArrayIndex]->glTermPoint[lCurRowNum]{3}-glCalcLoc{3} 

      '********************将计算出来的码垛点位赋值给实际拆垛点坐标变量********************************************
      glActualPltPoint=glCalcLoc
      '***************************判断计算出的实际拆垛点是否可达***************************************************
	  call JudgeLimit(TotalArrayIndex,glActualPltPoint)       
      '************************************************************************************************************
    
        select case TotalPltArray[TotalArrayIndex]->lHorPltMotFlag  
        case 1  '*************单组路径运动***********************************************************************
        
           '*************单组路径计算实际趋近点******************************************************************
           '*********将趋近点、参考点、回退点的点位赋值给中间变量以便计算△值和Inverse***************************
           glOneLoc=TotalPltArray[TotalArrayIndex]->glSinApproachPoint
           glTwoLoc=TotalPltArray[TotalArrayIndex]->glSinRefPoint
           glThreeLoc=TotalPltArray[TotalArrayIndex]->glSinBackPoint
           
           '*************************根据参考点位求出Inverse值***************************************************
           glInverPT=Inverse(glTwoLoc) 
           
           '****************************根据趋近点位求出△值***************************************************** 
           glDeltaVal=glInverPT:glOneLoc
           
           '********************将计算出的点位赋值给实际趋近点位变量*********************************************
           glSinActualAppPoint=glActualPltPoint:glDeltaVal
          '***************************判断计算出的实际趋近点是否可达*******************************************
	       call JudgeLimit(TotalArrayIndex,glSinActualAppPoint)     

           '*****************************************************************************************************
           
           '*************单组路径计算实际回退点******************************************************************
           '*************************根据参考点位求出Inverse值***************************************************
           glInverPT=Inverse(glTwoLoc) 
           
           '****************************根据回退点位求出△值***************************************************** 
           glDeltaVal=glInverPT:glThreeLoc
           
           '********************将计算出的点位赋值给实际回退点位变量*********************************************
           glSinActualBackPoint=glActualPltPoint:glDeltaVal  
          '***************************判断计算出的实际回退点是否可达*******************************************
	       call JudgeLimit(TotalArrayIndex,glSinActualBackPoint)  
           '*****************************************************************************************************

        case 2  '*************双组路径运动***********************************************************************
        
                   '*************双组路径计算实际趋近点和回退点**********************************************************
           '*********将趋近点、参考点、回退点的点位赋值给中间变量以便计算△值和Inverse***************************
          for i = 1 to 2  
             glOneLoc=TotalPltArray[TotalArrayIndex]->glDouApproachPoint[i]
             glTwoLoc=TotalPltArray[TotalArrayIndex]->glDouRefPoint
             glThreeLoc=TotalPltArray[TotalArrayIndex]->glDouBackPoint[i]
          
             '*************************根据参考点位求出Inverse值***********************************************
             glInverPT=Inverse(glTwoLoc) 
             
             '****************************根据趋近点位求出△值************************************************* 
             glDeltaVal=glInverPT:glOneLoc
             
             '********************将计算出的点位赋值给实际趋近点位变量*****************************************
             glDouActualAppPoint[i]=glActualPltPoint:glDeltaVal
            '***************************判断计算出的实际趋近点是否可达***************************************
	       call JudgeLimit(TotalArrayIndex,glDouActualAppPoint[i])      

             '*************************************************************************************************
             
             '*************************根据参考点位求出Inverse值***********************************************
             glInverPT=Inverse(glTwoLoc) 
             
             '****************************根据回退点位求出△值************************************************* 
             glDeltaVal=glInverPT:glThreeLoc
             
             '********************将计算出的点位赋值给实际回退点位变量*****************************************
             glDouActualBackPoint[i]=glActualPltPoint:glDeltaVal
            '***************************判断计算出的实际回退点是否可达***************************************
	       call JudgeLimit(TotalArrayIndex,glDouActualBackPoint[i])       

               '*************************************************************************************************   
          next i 

        case 3  '*************龙门跳运动*************************************************************************
           if robot.ElementSize = 4 then
               lZmaxHeight=robot.j[3].pmax-5-TotalPltArray[TotalArrayIndex]->glCalibratedFrame[lCurRowNum]{3}
               glOneLoc=glActualPltPoint			   
               glOneLoc{3}= lZmaxHeight
			   glLMJumpTopPoint=glOneLoc
			   '*************4轴机型龙门跳运动计算实际过渡点（回退点）*******************************************
			   '*************************根据参考点位求出Inverse值***********************************************
			   glTwoLoc=TotalPltArray[TotalArrayIndex]->glLmJumpRefPoint
			   glThreeLoc=TotalPltArray[TotalArrayIndex]->glLmJumpTransPoint
			 
			   glInverPT=Inverse(glTwoLoc) 
		   
			   '****************************根据回退点位求出△值************************************************* 
			   glDeltaVal=glInverPT:glThreeLoc
		   
			   '********************将计算出的点位赋值给实际回退点位变量*****************************************
			   glLMJumpActualTransPoint=glActualPltPoint:glDeltaVal  
			   '***************************判断计算出的实际过渡点是否可达****************************************
			  call JudgeLimit(TotalArrayIndex,glLMJumpActualTransPoint)    
			'************************************************************************************************
           end if
           if robot.ElementSize = 6 then
               glCalcLoc{3}=glCalcLoc{3}+TotalPltArray[TotalArrayIndex]->lLiftHeight
               glLMJumpTopPoint=glCalcLoc                                                '6轴机型龙门跳运动上方点
			   
				'***************************判断计算出的实际龙门跳点是否可达*************************************
	           call JudgeLimit(TotalArrayIndex,glLMJumpTopPoint)    
				'************************************************************************************************             

               '*************6轴机型龙门跳运动计算实际过渡点（回退点）*******************************************
               '*************************根据参考点位求出Inverse值***********************************************
               glTwoLoc=TotalPltArray[TotalArrayIndex]->glLmJumpRefPoint
               glThreeLoc=TotalPltArray[TotalArrayIndex]->glLmJumpTransPoint
             
               glInverPT=Inverse(glTwoLoc) 
           
               '****************************根据回退点位求出△值************************************************* 
               glDeltaVal=glInverPT:glThreeLoc
           
               '********************将计算出的点位赋值给实际回退点位变量*****************************************
               glLMJumpActualTransPoint=glActualPltPoint:glDeltaVal
            '**********************判断计算出的实际龙门跳过渡点是否可达**************************************
	           call JudgeLimit(TotalArrayIndex,glLMJumpActualTransPoint)      

               '*************************************************************************************************               
           end if
   
        end select       
  end select
   '*************将在标定坐标下计算得到的码垛点、趋近点和回退点再转换为通用坐标系下的点位********************************
   call PwpToPworld(TotalArrayIndex,lCurRowNum)
   lSetWorkpieceFlag=True
end sub

'***********************************************************************************************************************
' sub Name:  CalcVerPlt
' Description: 垂直码垛计算码垛/拆垛点、回退点和趋近点             
' Author:   Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: None                   
' Return Value: long:
' Algorithm:  计算前需要将默认坐标系下示教得到的参考点位进行坐标变换，计算完成后再转换回去
' Global Variables Used:
' Revisions:
'***********************************************************************************************************************

public sub CalcVerPlt(byval TotalVerArrayIndex as long )

   dim lCurrWorkpieceNum as long     '经过判断后参与点位计算的当前的工件编号
      
   dim XSpacing as double            '参考点之间的X坐标差值，用于计算行列数
   dim YSpacing as double            '参考点之间的Y坐标差值，用于计算行列数
   dim ZSpacing as double            '参考点之间的Z坐标差值，用于计算行列数
   dim dDistance as double           '参考点之间的空间距离， 用于计算行列数
   dim lRowOffset as double          '行偏移=工件宽度+行间距
   dim lColumnOffset as double       '列偏移=工件长度+列间距
   dim lHeightOffset as double       '层高偏移=工件高度+隔板高度
   
   dim i as long =1  
   dim k as long =1
   dim s as long =1
   dim dTemp as double
   dim lRetPlyNum as long            '用于判断当前工件属于哪一层
   dim lRetRowNum as long            '用于判断当前工件属于哪一行
   dim lRetColumNum as long          '用于判断当前工件属于哪一列
   
      '*************将在通用坐标系下的示教得到点转换为标定坐标下的点参与码垛点、趋近点和回退点的计算*******************
   call VerPltPworldToPwp(TotalVerArrayIndex)
   
   '*****************根据参考点1和2、列间距、工件长度计算垂直码垛每层工件的列数和偏移量*****************************
   XSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointTwo{1}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{1}
   YSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointTwo{2}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{2}
   ZSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointTwo{3}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{3}
   
   dDistance=sqrt(XSpacing^2+YSpacing^2+ZSpacing^2)
   
   dTemp=dDistance/(TotalVerPltArray[TotalVerArrayIndex]->llengthofWorkpiece+TotalVerPltArray[TotalVerArrayIndex]->lColumnSpacing)+1
   '列数取整
   lCalcColumnCount=int(dTemp)
   
   '*****************根据参考点1和3、行间距、工件宽度计算垂直码垛每层工件的行数和偏移量*****************************
   XSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointThree{1}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{1}
   YSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointThree{2}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{2}
   ZSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointThree{3}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{3}
   
   dDistance=sqrt(XSpacing^2+YSpacing^2+ZSpacing^2)
   
   dTemp=dDistance/(TotalVerPltArray[TotalVerArrayIndex]->lwidthofWorkpiece+TotalVerPltArray[TotalVerArrayIndex]->lRowSpacing)+1
   '行数取整
   lCalcRowCount=int(dTemp)
   
   '*****************根据工件长宽高计算垂直码垛相邻工件的行偏移、列偏移和层高偏移***********************************   
   lRowOffset=TotalVerPltArray[TotalVerArrayIndex]->lwidthofWorkpiece+TotalVerPltArray[TotalVerArrayIndex]->lRowSpacing 
   lColumnOffset=TotalVerPltArray[TotalVerArrayIndex]->llengthofWorkpiece+TotalVerPltArray[TotalVerArrayIndex]->lColumnSpacing  
   lHeightOffset=TotalVerPltArray[TotalVerArrayIndex]->lHeightofClapBoard+TotalVerPltArray[TotalVerArrayIndex]->lHeightofWorkpiece  
   select case TotalVerPltArray[TotalVerArrayIndex]->lVerStackType
        case 1  '1-表示码垛
       '*****************根据当面已经码垛的码垛工件数计算实际码垛点******************************************************
       lCurrWorkpieceNum=TotalVerPltArray[TotalVerArrayIndex]->lVerCurrPalletNum
       
       if lCurrWorkpieceNum >= 0 and lCurrWorkpieceNum < lCalcColumnCount*lCalcRowCount*(TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies) then
       '**********************根据当前工件数判断工件属于哪一层***********************************************************
        while i <= TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies
           if lCurrWorkpieceNum < i*lCalcColumnCount*lCalcRowCount then
             lRetPlyNum=i
             goto DetectPlyNum
          else 
             i=i+1
          end if
           sleep 10
        end while
        '**********************根据当前工件数判断工件属于哪一行***********************************************************
        DetectPlyNum:
        
        if lRetPlyNum >1 then
           lCurrWorkpieceNum=lCurrWorkpieceNum-((lRetPlyNum-1)*lCalcColumnCount*lCalcRowCount)
        end if
        
           while k <= lCalcRowCount
            if lCurrWorkpieceNum < k*lCalcColumnCount then
              lRetRowNum=k
              goto DetectColumuNum
            else
              k=k+1
            end if
            sleep 10
           end while
        '**********************根据当前工件所在行数判断工件属于哪一列******************************************************   
         DetectColumuNum:  
           lRetColumNum=lCalcColumnCount-((lRetRowNum*lCalcColumnCount-1)-lCurrWorkpieceNum)
           '********************根据工件所在层数编号、行数编号、列数编号计算当前工件码垛点点位*****************************
           '********************每一层码垛点的计算是以参考点1的位置为基准进行行/列偏移进行计算*****************************         
           '将垂直码垛的参考点1赋值给中间变量
           glVerPltCalcLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne
           glVerPltCalcLoc{3}=glVerPltCalcLoc{3}+(lRetPlyNum-1)*lHeightOffset

           glVerPltCalcLoc{1}=(lRetColumNum-1)*lColumnOffset
           glVerPltCalcLoc{1}=glVerPltCalcLoc{1}+TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{1}
           
           glVerPltCalcLoc{2}=(lRetRowNum-1)*lRowOffset
           glVerPltCalcLoc{2}=glVerPltCalcLoc{2}+TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{2}

          
           glVerActualPltPoint=glVerPltCalcLoc
		   '**************************判断点位是否可达*********************************************************************          
           call JudgeLimit(TotalVerArrayIndex,glVerActualPltPoint)

           select case TotalVerPltArray[TotalVerArrayIndex]->lVerPltMotFlag
           case 1
               '-----------单组路劲趋近回退点计算---------------
               '*********将趋近点、参考点、回退点的点位赋值给中间变量以便计算△值和Inverse*********************************
               glVerOneLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerSinApproachPoint
               glVerTwoLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerSinRefPoint
               glVerThreeLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerSinBackPoint
               
               '*************************根据参考点位求出Inverse值**************************************************
               glVerInverPT=Inverse(glVerTwoLoc) 
               
               '****************************根据趋近点位求出△值**************************************************** 
               glVerDeltaVal=glVerInverPT:glVerOneLoc
               
               '********************将计算出的点位赋值给实际趋近点位变量********************************************
             
               glVerSinActualAppPoint=glVerActualPltPoint:glVerDeltaVal
               '**************************判断点位是否可达**********************************************************               
               call JudgeLimit(TotalVerArrayIndex,glVerSinActualAppPoint)
               
               '*************************根据参考点位求出Inverse值**************************************************
               glVerInverPT=Inverse(glVerTwoLoc) 
               
               '****************************根据回退点位求出△值**************************************************** 
               glVerDeltaVal=glVerInverPT:glVerThreeLoc
               
               '********************将计算出的点位赋值给实际回退点位变量********************************************
               glVerSinActualBackPoint=glVerActualPltPoint:glVerDeltaVal
               '**************************判断点位是否可达**********************************************************               
               call JudgeLimit(TotalVerArrayIndex,glVerSinActualBackPoint)
			   
           case 2
               '-----------双组路劲趋近回退点计算---------------
             for s = 1 to 2  
               glVerOneLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerDouApproachPoint[s]
               glVerTwoLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerDouRefPoint
               glVerThreeLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerDouBackPoint[s]
            
               '*************************根据参考点位求出Inverse值**************************************************
               glVerInverPT=Inverse(glVerTwoLoc) 
               
               '****************************根据趋近点位求出△值****************************************************  
               glVerDeltaVal=glVerInverPT:glVerOneLoc
               
               '********************将计算出的点位赋值给实际趋近点位变量********************************************
               glVerDouActualAppPoint[s]=glVerActualPltPoint:glVerDeltaVal
               '**************************判断点位是否可达**********************************************************
               call JudgeLimit(TotalVerArrayIndex,glVerDouActualAppPoint[s])
               
               '*************************根据参考点位求出Inverse值**************************************************
               glVerInverPT=Inverse(glVerTwoLoc) 
               
               '****************************根据回退点位求出△值****************************************************  
               glVerDeltaVal=glVerInverPT:glVerThreeLoc
               
               '********************将计算出的点位赋值给实际回退点位变量********************************************
               glVerDouActualBackPoint[s]=glVerActualPltPoint:glVerDeltaVal
               '**************************判断点位是否可达**********************************************************               
               call JudgeLimit(TotalVerArrayIndex,glVerDouActualBackPoint[s])
             next s 
           end select
      else 
        print "The current number of workpieces exceeds the set value!!!"
      end if
    case 2   '2-表示拆垛
       '*****************根据当面已经拆垛的码垛工件数计算实际拆垛点******************************************************
       lCurrWorkpieceNum=TotalVerPltArray[TotalVerArrayIndex]->lVerCurrDepalletNum    
       if lCurrWorkpieceNum >= 0 and lCurrWorkpieceNum < lCalcColumnCount*lCalcRowCount*(TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies) then
       '**********************根据当前工件数判断工件属于哪一层***********************************************************
        while i <= TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies
           if lCurrWorkpieceNum < i*lCalcColumnCount*lCalcRowCount then
             lRetPlyNum=i
             goto DetectDepltPlyNum
          else 
             i=i+1
          end if
           sleep 10
        end while
        '**********************根据当前工件数判断工件属于哪一行***********************************************************
        DetectDepltPlyNum:
        
        if lRetPlyNum >1 then
           lCurrWorkpieceNum=lCurrWorkpieceNum-((lRetPlyNum-1)*lCalcColumnCount*lCalcRowCount)
        end if
        
           while k <= lCalcRowCount
            if lCurrWorkpieceNum < k*lCalcColumnCount then
              lRetRowNum=k
              goto DetectDepltColumuNum
            else
              k=k+1
            end if
            sleep 10
           end while
        '**********************根据当前工件所在行数判断工件属于哪一列******************************************************   
         DetectDepltColumuNum:  
           lRetColumNum=lCalcColumnCount-((lRetRowNum*lCalcColumnCount-1)-lCurrWorkpieceNum)
           '********************根据工件所在层数编号、行数编号、列数编号计算当前工件码垛点点位*****************************
           '********************每一层拆垛点的计算是以参考点1的位置为基准进行行/列偏移进行计算*****************************         
           '将垂直码垛的参考点1赋值给中间变量
           glVerPltCalcLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne
           glVerPltCalcLoc{3}=glVerPltCalcLoc{3}+(TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies-lRetPlyNum)*lHeightOffset

           glVerPltCalcLoc{1}=(lRetColumNum-1)*lColumnOffset
           glVerPltCalcLoc{1}=glVerPltCalcLoc{1}+TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{1}
           
           glVerPltCalcLoc{2}=(lRetRowNum-1)*lRowOffset
           glVerPltCalcLoc{2}=glVerPltCalcLoc{2}+TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{2}
           
           glVerActualDepltPoint=glVerPltCalcLoc
           '**************************判断点位是否可达**********************************************************           
           call JudgeLimit(TotalVerArrayIndex,glVerActualDepltPoint)
		   
           select case TotalVerPltArray[TotalVerArrayIndex]->lVerPltMotFlag
           case 1
               '-----------单组路劲趋近回退点计算---------------
               '*********将趋近点、参考点、回退点的点位赋值给中间变量以便计算△值和Inverse********************************
               glVerOneLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerSinApproachPoint
               glVerTwoLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerSinRefPoint
               glVerThreeLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerSinBackPoint
               
               '*************************根据参考点位求出Inverse值**************************************************
               glVerInverPT=Inverse(glVerTwoLoc) 
               
               '****************************根据趋近点位求出△值**************************************************** 
               glVerDeltaVal=glVerInverPT:glVerOneLoc
               
               '********************将计算出的点位赋值给实际趋近点位变量********************************************
               glVerSinActualAppPoint=glVerActualDepltPoint:glVerDeltaVal
               '**************************判断点位是否可达**********************************************************               
               call JudgeLimit(TotalVerArrayIndex,glVerSinActualAppPoint)
               
               '*************************根据参考点位求出Inverse值**************************************************
               glVerInverPT=Inverse(glVerTwoLoc) 
               
               '****************************根据回退点位求出△值**************************************************** 
               glVerDeltaVal=glVerInverPT:glVerThreeLoc
               
               '********************将计算出的点位赋值给实际回退点位变量********************************************
               glVerSinActualBackPoint=glVerActualDepltPoint:glVerDeltaVal
               '**************************判断点位是否可达**********************************************************               
               call JudgeLimit(TotalVerArrayIndex,glVerSinActualBackPoint) 
			   
           case 2
               '-----------双组路劲趋近回退点计算---------------
             for s = 1 to 2  
               glVerOneLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerDouApproachPoint[s]
               glVerTwoLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerDouRefPoint
               glVerThreeLoc=TotalVerPltArray[TotalVerArrayIndex]->glVerDouBackPoint[s]
            
               '*************************根据参考点位求出Inverse值**************************************************
               glVerInverPT=Inverse(glVerTwoLoc) 
               
               '****************************根据趋近点位求出△值****************************************************  
               glVerDeltaVal=glVerInverPT:glVerOneLoc
               
               '********************将计算出的点位赋值给实际趋近点位变量********************************************
               glVerDouActualAppPoint[s]=glVerActualDepltPoint:glVerDeltaVal
               '**************************判断点位是否可达**********************************************************               
               call JudgeLimit(TotalVerArrayIndex,glVerDouActualAppPoint[s])
               
               '*************************根据参考点位求出Inverse值**************************************************
               glVerInverPT=Inverse(glVerTwoLoc) 
               
               '****************************根据回退点位求出△值****************************************************  
               glVerDeltaVal=glVerInverPT:glVerThreeLoc
               
               '********************将计算出的点位赋值给实际回退点位变量********************************************
               glVerDouActualBackPoint[s]=glVerActualDepltPoint:glVerDeltaVal
               '**************************判断点位是否可达**********************************************************               
               call JudgeLimit(TotalVerArrayIndex,glVerDouActualBackPoint[s])
             next s 
           end select           
      else 
        print "The current number of workpieces exceeds the set value!!!"
      end if           
  end select
   '*************将在标定坐标下计算得到的码垛点、趋近点和回退点再转换为通用坐标系下的点位******************************
   call VerPltPwpToPworld(TotalVerArrayIndex)
   lSetWorkpieceFlag=True
end sub

'***********************************************************************************************************************
' function Name: CopyChannelData
' Description: 水平码垛设置通道数拷贝
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function CopyChannelData(byval TotalArrayIndex as long) as long
   dim i as long = 1
   for i =1 to 5
      glCopyAndPasteAr[i]=TotalPltArray[TotalArrayIndex]->glStartPoint[i]
    glCopyAndPasteAr[i+5]=TotalPltArray[TotalArrayIndex]->glTermPoint[i]
    glCopyAndPasteAr[i+10]=TotalPltArray[TotalArrayIndex]->glCalibratedFrame[i]
   next i

   glCopyAndPasteAr[16]=TotalPltArray[TotalArrayIndex]->glSinRefPoint
   glCopyAndPasteAr[17]=TotalPltArray[TotalArrayIndex]->glSinApproachPoint
   glCopyAndPasteAr[18]=TotalPltArray[TotalArrayIndex]->glSinBackPoint
   glCopyAndPasteAr[19]=TotalPltArray[TotalArrayIndex]->glDouRefPoint
   glCopyAndPasteAr[20]=TotalPltArray[TotalArrayIndex]->glDouApproachPoint[1]
   glCopyAndPasteAr[21]=TotalPltArray[TotalArrayIndex]->glDouApproachPoint[2]
   glCopyAndPasteAr[22]=TotalPltArray[TotalArrayIndex]->glDouBackPoint[1]
   glCopyAndPasteAr[23]=TotalPltArray[TotalArrayIndex]->glDouBackPoint[2]
 
   lCopyAndPaste[1]=TotalPltArray[TotalArrayIndex]->lLiftHeight
   lCopyAndPaste[2]=TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt
   lCopyAndPaste[3]=TotalPltArray[TotalArrayIndex]->lCurrPalletNum
   
   lCopyAndPaste[5]=TotalPltArray[TotalArrayIndex]->lStackType
   lCopyAndPaste[6]=TotalPltArray[TotalArrayIndex]->lHorPltMotFlag
   ?saveNewPltData
   CopyChannelData=0

end function

'***********************************************************************************************************************
' function Name: PasteChannelData
' Description: 水平码垛设置通道数粘贴
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function PasteChannelData(byval TotalArrayIndex as long) as long
   dim i as long = 1
   for i =1 to 5
      TotalPltArray[TotalArrayIndex]->glStartPoint[i]=glCopyAndPasteAr[i]
    TotalPltArray[TotalArrayIndex]->glTermPoint[i]=glCopyAndPasteAr[i+5]
    TotalPltArray[TotalArrayIndex]->glCalibratedFrame[i]=glCopyAndPasteAr[i+10]
   next i
   
   TotalPltArray[TotalArrayIndex]->glSinRefPoint=glCopyAndPasteAr[16]
   TotalPltArray[TotalArrayIndex]->glSinApproachPoint=glCopyAndPasteAr[17]
   TotalPltArray[TotalArrayIndex]->glSinBackPoint=glCopyAndPasteAr[18]
   TotalPltArray[TotalArrayIndex]->glDouRefPoint=glCopyAndPasteAr[19]
   TotalPltArray[TotalArrayIndex]->glDouApproachPoint[1]=glCopyAndPasteAr[20]
   TotalPltArray[TotalArrayIndex]->glDouApproachPoint[2]=glCopyAndPasteAr[21]
   TotalPltArray[TotalArrayIndex]->glDouBackPoint[1]=glCopyAndPasteAr[22]
   TotalPltArray[TotalArrayIndex]->glDouBackPoint[2]=glCopyAndPasteAr[23]
 
   TotalPltArray[TotalArrayIndex]->lLiftHeight=lCopyAndPaste[1]
   TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt=lCopyAndPaste[2]
   TotalPltArray[TotalArrayIndex]->lCurrPalletNum=lCopyAndPaste[3]
   
   TotalPltArray[TotalArrayIndex]->lStackType=lCopyAndPaste[5]
   TotalPltArray[TotalArrayIndex]->lHorPltMotFlag= lCopyAndPaste[6]
   ?saveNewPltData
   PasteChannelData=0

end function

'***********************************************************************************************************************
' function Name: VerCopyChannelData
' Description: 垂直码垛通道数据拷贝
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function VerCopyChannelData(byval TotalVerArrayIndex as long) as long
   glVerCopyAndPasteAr[1]=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne
   glVerCopyAndPasteAr[2]=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointTwo
   glVerCopyAndPasteAr[3]=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointThree
   glVerCopyAndPasteAr[4]=TotalVerPltArray[TotalVerArrayIndex]->glVerSinRefPoint
   glVerCopyAndPasteAr[5]=TotalVerPltArray[TotalVerArrayIndex]->glVerSinApproachPoint
   glVerCopyAndPasteAr[6]=TotalVerPltArray[TotalVerArrayIndex]->glVerSinBackPoint
   glVerCopyAndPasteAr[7]=TotalVerPltArray[TotalVerArrayIndex]->glVerDouRefPoint
   glVerCopyAndPasteAr[8]=TotalVerPltArray[TotalVerArrayIndex]->glVerDouApproachPoint[1]
   glVerCopyAndPasteAr[9]=TotalVerPltArray[TotalVerArrayIndex]->glVerDouApproachPoint[2]
   glVerCopyAndPasteAr[10]=TotalVerPltArray[TotalVerArrayIndex]->glVerDouBackPoint[1]
   glVerCopyAndPasteAr[11]=TotalVerPltArray[TotalVerArrayIndex]->glVerDouBackPoint[2]
   glVerCopyAndPasteAr[12]=TotalVerPltArray[TotalVerArrayIndex]->glVerCalibratedFrame
   lVerCopyAndPaste[1]=TotalVerPltArray[TotalVerArrayIndex]->llengthofWorkpiece
   lVerCopyAndPaste[2]=TotalVerPltArray[TotalVerArrayIndex]->lWidthofWorkpiece
   lVerCopyAndPaste[3]=TotalVerPltArray[TotalVerArrayIndex]->lHeightofWorkpiece
   lVerCopyAndPaste[4]=TotalVerPltArray[TotalVerArrayIndex]->lHeightofClapBoard
   lVerCopyAndPaste[5]=TotalVerPltArray[TotalVerArrayIndex]->lRowSpacing
   lVerCopyAndPaste[6]=TotalVerPltArray[TotalVerArrayIndex]->lColumnSpacing
   lVerCopyAndPaste[7]=TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies
   lVerCopyAndPaste[8]=TotalVerPltArray[TotalVerArrayIndex]->lVerCurrPalletNum
   lVerCopyAndPaste[9]=TotalVerPltArray[TotalVerArrayIndex]->lVerCurrDepalletNum
   
   lVerCopyAndPaste[12]=TotalVerPltArray[TotalVerArrayIndex]->lVerStackType
   lVerCopyAndPaste[13]=TotalVerPltArray[TotalVerArrayIndex]->lVerPltMotFlag
   lVerCopyAndPaste[14]=TotalVerPltArray[TotalVerArrayIndex]->lVerToolFrameNum
   ?saveNewVerPltData
   VerCopyChannelData=0

end function

'***********************************************************************************************************************
' function Name: VerPasteChannelData
' Description: 垂直码垛通道数据粘贴
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function VerPasteChannelData(byval TotalVerArrayIndex as long) as long
   TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne=glVerCopyAndPasteAr[1]
   TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointTwo=glVerCopyAndPasteAr[2]
   TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointThree=glVerCopyAndPasteAr[3]
   TotalVerPltArray[TotalVerArrayIndex]->glVerSinRefPoint=glVerCopyAndPasteAr[4]
   TotalVerPltArray[TotalVerArrayIndex]->glVerSinApproachPoint=glVerCopyAndPasteAr[5]
   TotalVerPltArray[TotalVerArrayIndex]->glVerSinBackPoint=glVerCopyAndPasteAr[6]
   TotalVerPltArray[TotalVerArrayIndex]->glVerDouRefPoint=glVerCopyAndPasteAr[7]
   TotalVerPltArray[TotalVerArrayIndex]->glVerDouApproachPoint[1]=glVerCopyAndPasteAr[8]
   TotalVerPltArray[TotalVerArrayIndex]->glVerDouApproachPoint[2]=glVerCopyAndPasteAr[9]
   TotalVerPltArray[TotalVerArrayIndex]->glVerDouBackPoint[1]=glVerCopyAndPasteAr[10]
   TotalVerPltArray[TotalVerArrayIndex]->glVerDouBackPoint[2]=glVerCopyAndPasteAr[11]
   TotalVerPltArray[TotalVerArrayIndex]->glVerCalibratedFrame=glVerCopyAndPasteAr[12]
   TotalVerPltArray[TotalVerArrayIndex]->llengthofWorkpiece=lVerCopyAndPaste[1]
   TotalVerPltArray[TotalVerArrayIndex]->lWidthofWorkpiece=lVerCopyAndPaste[2]
   TotalVerPltArray[TotalVerArrayIndex]->lHeightofWorkpiece=lVerCopyAndPaste[3]
   TotalVerPltArray[TotalVerArrayIndex]->lHeightofClapBoard=lVerCopyAndPaste[4]
   TotalVerPltArray[TotalVerArrayIndex]->lRowSpacing=lVerCopyAndPaste[5]
   TotalVerPltArray[TotalVerArrayIndex]->lColumnSpacing=lVerCopyAndPaste[6]
   TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies=lVerCopyAndPaste[7]
   TotalVerPltArray[TotalVerArrayIndex]->lVerCurrPalletNum=lVerCopyAndPaste[8]
   TotalVerPltArray[TotalVerArrayIndex]->lVerCurrDepalletNum=lVerCopyAndPaste[9]
   
   TotalVerPltArray[TotalVerArrayIndex]->lVerStackType=lVerCopyAndPaste[12]
   TotalVerPltArray[TotalVerArrayIndex]->lVerPltMotFlag=lVerCopyAndPaste[13]
   TotalVerPltArray[TotalVerArrayIndex]->lVerToolFrameNum=lVerCopyAndPaste[14]
   ?saveNewVerPltData
   VerPasteChannelData=0

end function

'***********************************************************************************************************************
' function Name: SpatialPointDetect
' Description: 水平码垛空间点位检测
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function SpatialPointDetect(byval TotalArrayIndex as long) as long
   dim i as long
   dim lCurrTempPltWorkPice as long
   dim lCurrTempDepltWorkPice as long
   
   if getStackType(TotalArrayIndex)=1 then
    lCurrTempPltWorkPice=getCurrWorkpieceCnt(TotalArrayIndex)
    for i=1 to TotalPltArray[TotalArrayIndex]->lAllRowCount*TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt
      TotalPltArray[TotalArrayIndex]->lCurrPalletNum=i-1
      call calcHorPlt(TotalArrayIndex)
    next i
    TotalPltArray[TotalArrayIndex]->lCurrPalletNum=lCurrTempPltWorkPice
   end if
   if getStackType(TotalArrayIndex)=2 then
    lCurrTempDepltWorkPice=getCurrWorkpieceCnt(TotalArrayIndex)
    for i=1 to TotalPltArray[TotalArrayIndex]->lAllRowCount*TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt
      TotalPltArray[TotalArrayIndex]->lCurrDepalletNum=i-1
      call calcHorPlt(TotalArrayIndex)
    next i
    TotalPltArray[TotalArrayIndex]->lCurrDepalletNum=lCurrTempDepltWorkPice
   end if
   SpatialPointDetect = 0
end function

'***********************************************************************************************************************
' function Name: VerSpatialPointDetect
' Description: 垂直码垛空间点位检测
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-为通道索引，索引从1开始，上限值为6
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function VerSpatialPointDetect(byval TotalVerArrayIndex as long) as long
   dim i as long
   dim lCurrTempPltWorkPice as long
   dim lCurrTempDepltWorkPice as long

   if getVerStackType(TotalVerArrayIndex)=1 then     '码垛点位空间检测 
       lCurrTempPltWorkPice=getVerCurrWorkpieceCnt(TotalVerArrayIndex)  
       for i=1 to (lCalcColumnCount*lCalcRowCount*TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies)-1
          TotalVerPltArray[TotalVerArrayIndex]->lVerCurrPalletNum=i-1        
          call CalcVerPlt(TotalVerArrayIndex)
       next i
       TotalVerPltArray[TotalVerArrayIndex]->lVerCurrPalletNum=lCurrTempPltWorkPice
   end if
   
   if getVerStackType(TotalVerArrayIndex)=2 then  '拆垛点位空间检测 
      lCurrTempDepltWorkPice=getVerDepltCurrWorkpieceCnt(TotalVerArrayIndex)
      for i=1 to (lCalcColumnCount*lCalcRowCount*TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies)-1
         TotalVerPltArray[TotalVerArrayIndex]->lVerCurrDepalletNum=i-1        
         call CalcVerPlt(TotalVerArrayIndex)
      next i
      TotalVerPltArray[TotalVerArrayIndex]->lVerCurrDepalletNum=lCurrTempDepltWorkPice
   end if
end function

'***********************************************************************************************************************
' function Name: InitNewPltData
' Description: 水平码垛数据初始化
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  None
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function InitNewPltData as long
dim i as long = 1
dim k as long = 1
dim m as long = 1
dim n as long = 1

dim Axis_Type as long = 0
dim glTemp as generic location
   if robot.ElementSize = 3 Then
      Axis_Type = TYPE_XYZ
   end if
   if robot.ElementSize = 4 Then
      Axis_Type = TYPE_XYZR
   end if
   if robot.ElementSize = 6 then
      Axis_Type=TYPE_XYZYPR
   end if
    glTemp = CASTLOCATION(0, Axis_Type)
   for i = 1 to 6
    '水平码垛结构体数据、变量初始化
       for m = 1 to 5
       TotalPltArray[i]->glStartPoint[m]=glTemp
       TotalPltArray[i]->glTermPoint[m]=glTemp
       TotalPltArray[i]->glPartPoint[m]=glTemp
       TotalPltArray[i]->glCalibratedFrame[m]=glTemp
       next m
    TotalPltArray[i]->glOriginalBase=glTemp
	TotalPltArray[i]->glOriginalTool=glTemp
	TotalPltArray[i]->glOriginalworkpiece=glTemp
	TotalPltArray[i]->glOriginalMachineTable=glTemp
	
     TotalPltArray[i]->glSinRefPoint=glTemp
     TotalPltArray[i]->glDouRefPoint=glTemp
     TotalPltArray[i]->glSinApproachPoint=glTemp
     TotalPltArray[i]->glSinBackPoint=glTemp
     TotalPltArray[i]->glLmJumpRefPoint=glTemp
     TotalPltArray[i]->glLmJumpTransPoint=glTemp     
     
     glLMJumpTopPoint=glTemp
     glActualPltPoint=glTemp
     
     for k = 1 to 2
      TotalPltArray[i]->glDouApproachPoint[k]=glTemp
      TotalPltArray[i]->glDouBackPoint[k]=glTemp
     next k
   next i
   for n=1 to 50
     glCopyAndPasteAr[n]=glTemp
   next n
   glTempCoordinate=glTemp
   InitNewPltData = 0
end function

'***********************************************************************************************************************
' function Name: InitNewVerPltData
' Description: 垂直码垛数据初始化
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  None
' Output Parameters: long
'                    0-success
'                    Not 0-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function InitNewVerPltData as long
dim i as long = 1
dim k as long = 1
dim n as long = 1

dim Axis_Type as long = 0
dim glTemp as generic location
   if robot.ElementSize = 3 Then
      Axis_Type = TYPE_XYZ
   end if
   if robot.ElementSize = 4 Then
      Axis_Type = TYPE_XYZR
   end if
   if robot.ElementSize = 6 then
      Axis_Type=TYPE_XYZYPR
   end if
    glTemp = CASTLOCATION(0, Axis_Type)
   for i = 1 to 6
     '垂直码垛结构体数据、变量初始化
	TotalVerPltArray[i]->lVerToolFrameNum=0
	
    TotalVerPltArray[i]->glVerRefPointOne=glTemp
    TotalVerPltArray[i]->glVerRefPointTwo=glTemp
    TotalVerPltArray[i]->glVerRefPointThree=glTemp
    
    TotalVerPltArray[i]->glVerSinRefPoint=glTemp
    TotalVerPltArray[i]->glVerSinApproachPoint=glTemp
    TotalVerPltArray[i]->glVerSinBackPoint=glTemp

    TotalVerPltArray[i]->glVerDouRefPoint=glTemp
    TotalVerPltArray[i]->glVerCalibratedFrame=glTemp
	TotalVerPltArray[i]->glVerOriginalBase=glTemp
	TotalVerPltArray[i]->glVerOriginalTool=glTemp
	TotalVerPltArray[i]->glVerOriginalWorkpiece=glTemp
	TotalVerPltArray[i]->glVerOriginalMachineTable=glTemp	
     for k = 1 to 2
     TotalVerPltArray[i]->glVerDouApproachPoint[k]=glTemp
     TotalVerPltArray[i]->glVerDouBackPoint[k]=glTemp
     next k
   next i
   for n=1 to 20
     glVerCopyAndPasteAr[n]=glTemp
   next n
   glTempVerCoordinate=glTemp
   InitNewVerPltData = 0
end function

'***********************************************************************************************************************
' function Name: saveNewPltData
' Description: 水平码垛数据保存
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  None
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function saveNewPltData as long
  dim i as long=1
  dim k as long=1
  dim sData as string
  dim sTemp as string
  dim lret as long=-1
  
  sData="PROGRAM CONTINUE"+CHR$(0x0d)+CHR$(0x0a)
  for i=1 to 6

     '*******************************码垛/拆垛标志位数据保存*************************************************************
     if TotalPltArray[i]->lStackType<>0 then
        printu$ sTemp,"TotalPltArray[#]->lStackType=#";i,TotalPltArray[i]->lStackType
        sData = sData + sTemp
     end if
     '****************************每排码垛/拆垛工件总数数据保存**********************************************************
     if TotalPltArray[i]->lAllWorkpieceCnt<>0 then 
        printu$ sTemp,"TotalPltArray[#]->lAllWorkpieceCnt=#";i,TotalPltArray[i]->lAllWorkpieceCnt
        sData = sData + sTemp  
     end if   
     '*******************************当前码垛工件数保存变量数据保存******************************************************
	
	printu$ sTemp,"TotalPltArray[#]->lCurrPalletNum=#";i,TotalPltArray[i]->lCurrPalletNum
	sData = sData + sTemp  
     '*******************************当前拆垛工件数保存变量数据保存******************************************************
	
	printu$ sTemp,"TotalPltArray[#]->lCurrDepalletNum=#";i,TotalPltArray[i]->lCurrDepalletNum
	sData = sData + sTemp        
     '**********************************码垛/拆垛排数数据保存************************************************************
     if TotalPltArray[i]->lAllRowCount<>0 then 
        printu$ sTemp,"TotalPltArray[#]->lAllRowCount=#";i,TotalPltArray[i]->lAllRowCount
        sData = sData + sTemp  
     end if
     '********************************码垛路径选择标志位数据保存*********************************************************
     if TotalPltArray[i]->lHorPltMotFlag<>0 then
        printu$ sTemp,"TotalPltArray[#]->lHorPltMotFlag=#";i,TotalPltArray[i]->lHorPltMotFlag
        sData = sData + sTemp
     end if  
     for k=1 to 5
		 '*********************************码垛起始点数据保存************************************************************
		 glSCompTempLoc = TotalPltArray[i]->glStartPoint[k]
		 if isPointChanged(glSCompTempLoc) = 1 then
			printu$ sTemp,"TotalPltArray[#]->glStartPoint[#]=#.####";i,k,TotalPltArray[i]->glStartPoint[k]
			sData = sData + sTemp
		 end if
		 '*********************************码垛参与点数据保存************************************************************
		 glSCompTempLoc = TotalPltArray[i]->glPartPoint[k]
		 if ispointchanged(glSCompTempLoc) = 1 then
			printu$ stemp,"TotalPltArray[#]->glPartPoint[#]=#.####";i,k,TotalPltArray[i]->glPartPoint[k]
			sdata = sdata + stemp
		 end if
		 '*********************************码垛终止点数据保存************************************************************
		 glSCompTempLoc = TotalPltArray[i]->glTermPoint[k]
		 if isPointChanged(glSCompTempLoc) = 1 then
			printu$ sTemp,"TotalPltArray[#]->glTermPoint[#]=#.####";i,k,TotalPltArray[i]->glTermPoint[k]
			sData = sData + sTemp
		 end if
		 glSCompTempLoc = TotalPltArray[i]->glCalibratedFrame[k]
		 '*******************************工件坐标系标定数据保存**********************************************************
		 if isPointChanged(glSCompTempLoc) = 1 then
			printu$ sTemp,"TotalPltArray[#]->glCalibratedFrame[#]=#.####";i,k,TotalPltArray[i]->glCalibratedFrame[k]
			sData = sData + sTemp
		 end if  
     next k 
	 
	'*******************************机器人运动之前基坐标系数据保存*******************************************************    
	printu$ sTemp,"TotalPltArray[#]->glOriginalBase=#.####";i,TotalPltArray[i]->glOriginalBase
	sData = sData + sTemp
	'*******************************机器人运动之前工具坐标系数据保存*****************************************************    
	printu$ sTemp,"TotalPltArray[#]->glOriginalTool=#.####";i,TotalPltArray[i]->glOriginalTool
	sData = sData + sTemp
	'*******************************机器人运动之前工件坐标系数据保存*****************************************************   
	printu$ sTemp,"TotalPltArray[#]->glOriginalworkpiece=#.####";i,TotalPltArray[i]->glOriginalworkpiece
	sData = sData + sTemp
	'*******************************机器人运动之前工作台坐标系数据保存***************************************************    
	printu$ sTemp,"TotalPltArray[#]->glOriginalMachineTable=#.####";i,TotalPltArray[i]->glOriginalMachineTable
	sData = sData + sTemp
	
   '*******************************单组路径参考点数据保存****************************************************************
    glSCompTempLoc = TotalPltArray[i]->glSinRefPoint 
    if isPointChanged(glSCompTempLoc) = 1 then
       printu$ sTemp,"TotalPltArray[#]->glSinRefPoint=#.####";i,TotalPltArray[i]->glSinRefPoint
       sData = sData + sTemp
    end if
   '*******************************双组路径参考点数据保存****************************************************************
    glSCompTempLoc = TotalPltArray[i]->glDouRefPoint 
    if isPointChanged(glSCompTempLoc) = 1 then
       printu$ sTemp,"TotalPltArray[#]->glDouRefPoint=#.####";i,TotalPltArray[i]->glDouRefPoint
       sData = sData + sTemp
    end if
      '*******************************单组路径趋近点数据保存*************************************************************
    glSCompTempLoc = TotalPltArray[i]->glSinApproachPoint 
    if isPointChanged(glSCompTempLoc) = 1 then
       printu$ sTemp,"TotalPltArray[#]->glSinApproachPoint=#.####";i,TotalPltArray[i]->glSinApproachPoint
       sData = sData + sTemp
    end if
      '********************************双组路劲趋近点数据保存************************************************************
    '双组路径第一个趋近点
    glDCompTempLoc[1] = TotalPltArray[i]->glDouApproachPoint[1]
    if isPointChanged(glDCompTempLoc[1]) = 1 then
       printu$ sTemp,"TotalPltArray[#]->glDouApproachPoint[1]=#.####";i,TotalPltArray[i]->glDouApproachPoint[1]
       sData = sData + sTemp
    end if
      '双组路径第二个趋近点
    glDCompTempLoc[2] = TotalPltArray[i]->glDouApproachPoint[2]
    if isPointChanged(glDCompTempLoc[2]) = 1 then
       printu$ sTemp,"TotalPltArray[#]->glDouApproachPoint[2]=#.####";i,TotalPltArray[i]->glDouApproachPoint[2]
       sData = sData + sTemp
    end if     
      '*******************************单组路径回退点数据保存*************************************************************
    glSCompTempLoc = TotalPltArray[i]->glSinBackPoint
    if isPointChanged(glSCompTempLoc) = 1 then
       printu$ sTemp,"TotalPltArray[#]->glSinBackPoint=#.####";i,TotalPltArray[i]->glSinBackPoint
       sData = sData + sTemp
    end if   
      '*******************************双组路径回退点数据保存*************************************************************
    '双组路径第一个回退点
    glDCompTempLoc[1] = TotalPltArray[i]->glDouBackPoint[1]
    if isPointChanged(glDCompTempLoc[1]) = 1 then
       printu$ sTemp,"TotalPltArray[#]->glDouBackPoint[1]=#.####";i,TotalPltArray[i]->glDouBackPoint[1]
       sData = sData + sTemp
    end if   
    '双组路径第二个回退点
    glDCompTempLoc[2] = TotalPltArray[i]->glDouBackPoint[2]
    if isPointChanged(glDCompTempLoc[2]) = 1 then
       printu$ sTemp,"TotalPltArray[#]->glDouBackPoint[2]=#.####";i,TotalPltArray[i]->glDouBackPoint[2]
       sData = sData + sTemp
    end if
     '***********************************龙门跳高度数据保存***************************************************************
     if TotalPltArray[i]->lLiftHeight<>0 then
        printu$ sTemp,"TotalPltArray[#]->lLiftHeight=#";i,TotalPltArray[i]->lLiftHeight
        sData = sData + sTemp
     end if 	
      '******************************龙门跳路径参考点数据保存*************************************************************	
	glSCompTempLoc = TotalPltArray[i]->glLmJumpRefPoint
    if isPointChanged(glSCompTempLoc) = 1 then
	   printu$ sTemp,"TotalPltArray[#]->glLmJumpRefPoint=#.####";i,TotalPltArray[i]->glLmJumpRefPoint
	   sData = sData + sTemp
    end if
      '******************************龙门跳路径过渡点数据保存*************************************************************	
	glSCompTempLoc = TotalPltArray[i]->glLmJumpTransPoint
    if isPointChanged(glSCompTempLoc) = 1 then
	   printu$ sTemp,"TotalPltArray[#]->glLmJumpTransPoint=#.####";i,TotalPltArray[i]->glLmJumpTransPoint
	   sData = sData + sTemp
    end if	
  next i
    '*******************************码垛通道编号数据保存****************************************************************
	if lHorChannelNum<>0 then
	   printu$ sTemp,"lHorChannelNum=#";lHorChannelNum
	   sData = sData + sTemp
	end if
   
   sData = sData +"TERMINATE PROGRAM"+ CHR$(0x0d) + CHR$(0x0a)
   sTemp="_NPltDAT.PRG"
   lret = saveNewPltFile(sTemp,sData)
   saveNewPltData = lret 
end function

'***********************************************************************************************************************
' function Name: saveNewVerPltData
' Description: 垂直码垛数据保存
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  None
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function saveNewVerPltData as long
  dim i as long=1
  dim sData as string
  dim sTemp as string
  dim lret as long=-1
  
  sData="PROGRAM CONTINUE"+CHR$(0x0d)+CHR$(0x0a)
    for i=1 to 6
  
        
        '****************************当前码垛/拆垛总工件数数据保存***************************************************
	    printu$ sTemp,"lVerPltAllWPCount[#]=#";i,lVerPltAllWPCount[i]
	    sData = sData + sTemp  
        '*****************************当前拆垛工件数数据保存*********************************************************
  	    printu$ sTemp,"TotalVerPltArray[#]->lVerCurrDepalletNum=#";i,TotalVerPltArray[i]->lVerCurrDepalletNum
	    sData = sData + sTemp  
	   
		'************************当前码垛选择的工具坐标系编号数据保存************************************************
        if TotalVerPltArray[i]->lVerToolFrameNum<>0 then 
           printu$ sTemp,"TotalVerPltArray[#]->lVerToolFrameNum=#";i,TotalVerPltArray[i]->lVerToolFrameNum
           sData = sData + sTemp  
        end if 		

        '**********************************垂直码垛总工件层数据保存**************************************************
        if TotalVerPltArray[i]->lVerNumofPlies<>0 then 
           printu$ sTemp,"TotalVerPltArray[#]->lVerNumofPlies=#";i,TotalVerPltArray[i]->lVerNumofPlies
           sData = sData + sTemp  
        end if
        '**********************************垂直码垛每层工件行间距数据保存********************************************
        if TotalVerPltArray[i]->lRowSpacing<>0 then 
           printu$ sTemp,"TotalVerPltArray[#]->lRowSpacing=#.####";i,TotalVerPltArray[i]->lRowSpacing
           sData = sData + sTemp  
        end if
        '**********************************垂直码垛每层工件列间距数据保存********************************************
        if TotalVerPltArray[i]->lColumnSpacing<>0 then 
           printu$ sTemp,"TotalVerPltArray[#]->lColumnSpacing=#.####";i,TotalVerPltArray[i]->lColumnSpacing
           sData = sData + sTemp  
        end if    
        '**********************************垂直码垛工件的长度数据保存***********************************************
        if TotalVerPltArray[i]->llengthofWorkpiece<>0 then 
           printu$ sTemp,"TotalVerPltArray[#]->llengthofWorkpiece=#.####";i,TotalVerPltArray[i]->llengthofWorkpiece
           sData = sData + sTemp  
        end if
        '**********************************垂直码垛工件的宽度数据保存***********************************************
        if TotalVerPltArray[i]->lWidthofWorkpiece<>0 then 
           printu$ sTemp,"TotalVerPltArray[#]->lWidthofWorkpiece=#.####";i,TotalVerPltArray[i]->lWidthofWorkpiece
           sData = sData + sTemp  
        end if
        '**********************************垂直码垛工件的高度数据保存***********************************************
        if TotalVerPltArray[i]->lHeightofWorkpiece<>0 then 
           printu$ sTemp,"TotalVerPltArray[#]->lHeightofWorkpiece=#.####";i,TotalVerPltArray[i]->lHeightofWorkpiece
           sData = sData + sTemp  
        end if
        '**********************************垂直码垛隔板的厚度数据保存***********************************************
        if TotalVerPltArray[i]->lHeightofClapBoard<>0 then 
           printu$ sTemp,"TotalVerPltArray[#]->lHeightofClapBoard=#.####";i,TotalVerPltArray[i]->lHeightofClapBoard
           sData = sData + sTemp  
        end if
        '**********************************垂直码垛/拆垛标志位数据保存***********************************************
        if TotalVerPltArray[i]->lVerStackType<>0 then 
           printu$ sTemp,"TotalVerPltArray[#]->lVerStackType=#";i,TotalVerPltArray[i]->lVerStackType
           sData = sData + sTemp  
        end if
        '**********************************垂直码垛/拆垛运动路径数据保存**********************************************
        if TotalVerPltArray[i]->lVerPltMotFlag<>0 then 
           printu$ sTemp,"TotalVerPltArray[#]->lVerPltMotFlag=#";i,TotalVerPltArray[i]->lVerPltMotFlag
           sData = sData + sTemp  
        end if      
        '************************垂直码垛参考点1数据保存************************************************************
        glVerSCompTempLoc = TotalVerPltArray[i]->glVerRefPointOne
        if isPointChanged(glVerSCompTempLoc) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerRefPointOne=#.####";i,TotalVerPltArray[i]->glVerRefPointOne
           sData = sData + sTemp
        end if
        '************************垂直码垛参考点2数据保存************************************************************
        glVerSCompTempLoc = TotalVerPltArray[i]->glVerRefPointTwo
        if isPointChanged(glVerSCompTempLoc) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerRefPointTwo=#.####";i,TotalVerPltArray[i]->glVerRefPointTwo
           sData = sData + sTemp
        end if
        '************************垂直码垛参考点3数据保存************************************************************
        glVerSCompTempLoc = TotalVerPltArray[i]->glVerRefPointThree
        if isPointChanged(glVerSCompTempLoc) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerRefPointThree=#.####";i,TotalVerPltArray[i]->glVerRefPointThree
           sData = sData + sTemp
        end if
        '************************垂直码垛单组路径参考点数据保存*****************************************************
        glVerSCompTempLoc = TotalVerPltArray[i]->glVerSinRefPoint
        if isPointChanged(glVerSCompTempLoc) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerSinRefPoint=#.####";i,TotalVerPltArray[i]->glVerSinRefPoint
           sData = sData + sTemp
        end if
        '************************垂直码垛单组路径趋近点数据保存*****************************************************
        glVerSCompTempLoc = TotalVerPltArray[i]->glVerSinApproachPoint
        if isPointChanged(glVerSCompTempLoc) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerSinApproachPoint=#.####";i,TotalVerPltArray[i]->glVerSinApproachPoint
           sData = sData + sTemp
        end if
        '************************垂直码垛单组路径回退点数据保存*****************************************************
        glVerSCompTempLoc = TotalVerPltArray[i]->glVerSinBackPoint
        if isPointChanged(glVerSCompTempLoc) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerSinBackPoint=#.####";i,TotalVerPltArray[i]->glVerSinBackPoint
           sData = sData + sTemp
        end if
        '************************垂直码垛双组路径参考点数据保存*****************************************************
        glVerSCompTempLoc = TotalVerPltArray[i]->glVerDouRefPoint
        if isPointChanged(glVerSCompTempLoc) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerDouRefPoint=#.####";i,TotalVerPltArray[i]->glVerDouRefPoint
           sData = sData + sTemp
        end if
        '*******************************双组路径趋近点数据保存*******************************************************
        '双组路径第一个趋近点
        glVerDCompTempLoc[1] = TotalVerPltArray[i]->glVerDouApproachPoint[1]
        if isPointChanged(glVerDCompTempLoc[1]) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerDouApproachPoint[1]=#.####";i,TotalVerPltArray[i]->glVerDouApproachPoint[1]
           sData = sData + sTemp
        end if   
        '双组路径第二个趋近点
        glVerDCompTempLoc[2] = TotalVerPltArray[i]->glVerDouApproachPoint[2]
        if isPointChanged(glVerDCompTempLoc[2]) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerDouApproachPoint[2]=#.####";i,TotalVerPltArray[i]->glVerDouApproachPoint[2]
           sData = sData + sTemp
        end if 
        '*******************************双组路径回退点数据保存*******************************************************
        '双组路径第一个趋近点
        glVerDCompTempLoc[1] = TotalVerPltArray[i]->glVerDouBackPoint[1]
        if isPointChanged(glVerDCompTempLoc[1]) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerDouBackPoint[1]=#.####";i,TotalVerPltArray[i]->glVerDouBackPoint[1]
           sData = sData + sTemp
        end if   
        '双组路径第二个趋近点
        glVerDCompTempLoc[2] = TotalVerPltArray[i]->glVerDouBackPoint[2]
        if isPointChanged(glVerDCompTempLoc[2]) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerDouBackPoint[2]=#.####";i,TotalVerPltArray[i]->glVerDouBackPoint[2]
           sData = sData + sTemp
        end if
        '*******************************工件坐标系标定数据保存*************************************************************
        glVerSCompTempLoc = TotalVerPltArray[i]->glVerCalibratedFrame
        if isPointChanged(glVerSCompTempLoc) = 1 then
           printu$ sTemp,"TotalVerPltArray[#]->glVerCalibratedFrame=#.####";i,TotalVerPltArray[i]->glVerCalibratedFrame
           sData = sData + sTemp
        end if 
		'*******************************机器人运动之前基坐标系数据保存*****************************************************    
		printu$ sTemp,"TotalVerPltArray[#]->glVerOriginalBase=#.####";i,TotalVerPltArray[i]->glVerOriginalBase
		sData = sData + sTemp
		'*******************************机器人运动之前工具坐标系数据保存***************************************************    
		printu$ sTemp,"TotalVerPltArray[#]->glVerOriginalTool=#.####";i,TotalVerPltArray[i]->glVerOriginalTool
		sData = sData + sTemp
		'*******************************机器人运动之前工件坐标系数据保存***************************************************   
		printu$ sTemp,"TotalVerPltArray[#]->glVerOriginalworkpiece=#.####";i,TotalVerPltArray[i]->glVerOriginalworkpiece
		sData = sData + sTemp
		'*******************************机器人运动之前工作台坐标系数据保存*************************************************    
		printu$ sTemp,"TotalVerPltArray[#]->glVerOriginalMachineTable=#.####";i,TotalVerPltArray[i]->glVerOriginalMachineTable
		sData = sData + sTemp
    next i
    '*******************************码垛通道编号数据保存****************************************************************
	if lVerChannelNum<>0 then
	   printu$ sTemp,"lVerChannelNum=#";lVerChannelNum
	   sData = sData + sTemp
	end if	
	
   sData = sData +"TERMINATE PROGRAM"+ CHR$(0x0d) + CHR$(0x0a)
   sTemp="_VPltDAT.PRG"
   lret = saveNewVerPltFile(sTemp,sData)
   saveNewVerPltData = lret 
end function

'***********************************************************************************************************************
' function Name: saveNewPltFile
' Description: 水平码垛文件保存
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  String
'                    sName-文件名，sData-数据内容
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function saveNewPltFile(sName as string,sData as string) as long 
dim lGetNext as long = TRUE
dim DeviceHandler as long=1
dim lRet as long = 0
  while lGetNext
    try
      Open  sName Mode="w" as #DeviceHandler 
      Print #DeviceHandler, sData
      close #DeviceHandler
      Sleep 5
      lGetNext = FALSE
    catch 5043  ' Port or file is already open
      DeviceHandler = DeviceHandler + 1
      if DeviceHandler > 255 then
        lGetNext = FALSE
        lRet=-1
      end if
    end try
  end while
  
saveNewPltFile = lRet
end function

'***********************************************************************************************************************
' function Name: saveNewVerPltFile
' Description: 垂直码垛文件保存
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  String
'                    sName-文件名，sData-数据内容
' Output Parameters: long
'                    0-success
'                    -1-Failed
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function saveNewVerPltFile(sName as string,sData as string) as long 
dim lGetNext as long = TRUE
dim DeviceHandler as long=1
dim lRet as long = 0
  while lGetNext
    try
      Open  sName Mode="w" as #DeviceHandler 
      Print #DeviceHandler, sData
      close #DeviceHandler
      Sleep 5
      lGetNext = FALSE
    catch 5043  ' Port or file is already open
      DeviceHandler = DeviceHandler + 1
      if DeviceHandler > 255 then
        lGetNext = FALSE
        lRet=-1
      end if
    end try
  end while
  
saveNewVerPltFile = lRet
end function

'***********************************************************************************************************************
' function Name: isPointChanged
' Description: 水平码垛判断点位数据是否改变，若改变则保存，否则不保存
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  generic location
'                    CurrPoint-传入的点位数据
' Output Parameters: long
'                    1-save data
'                    0-not save
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function isPointChanged(byval CurrPoint as generic location)as long
  dim isRet as long = 0
  dim i as long = 1
    for i = 1 to robot.ElementSize
       iF CurrPoint{i}<-0.001 then
         goto lableddd
       end if
       if CurrPoint{i}>0.001 then
         goto lableddd
       end if
    next i
    if i <> robot.ElementSize+1 then
       lableddd:
       isRet = 1
    end if
  isPointChanged = isRet
end function

'***********************************************************************************************************************
' function Name: isPointValue
' Description: 水平码垛判断点位数据是否有值（0除外）
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  generic location
'                    CurrPoint-传入的点位数据
' Output Parameters: long
'                    1-点位数据无值
'                    0-点位数据有值
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function isPointValue(byval CurrPoint as generic location)as long
  dim isRet as long = 0
  dim i as long = 1
  dim lZeroNum as long =0
    for i = 1 to robot.ElementSize
       iF CurrPoint{i}=0 then
         lZeroNum=lZeroNum+1
       end if
    next i
  if lZeroNum=robot.ElementSize then
       isRet=1
    else
         isRet=0   
  end if
 isPointValue=isRet
end function

'***********************************************************************************************************************
' function Name: isFileExist
' Description: 水平码垛判断文件是否存在
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  String
'                    sfileName-传入的文件名
' Output Parameters: long
'                    0-文件存在
'                   -1-文件不存在
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function isFileExist(byval sfileName as string) as long
dim lGetNext as long = TRUE
dim DeviceHandler as long=1
dim lRet as long = 0
  while lGetNext
   try
      Open  sfileName Mode="r" as #DeviceHandler 
      close #DeviceHandler
      Sleep 5
    lRet=0
      lGetNext = FALSE
    catch 5043  ' Port or file is already open
     DeviceHandler = DeviceHandler + 1
     if DeviceHandler > 255 then
        lGetNext = FALSE
       lRet=-1
      end if
  catch 4033  ' file don't exist
    lGetNext = FALSE
    lRet=-1
   end try
  end while
  isFileExist=lRet
end function

'***********************************************************************************************************************
' function Name: JudgeCurWorkPiece
' Description: 根据当前码垛/拆垛工件数判断当前工件所在的排数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    except 0 and -1-success
'                    -1-Failed or lCurrPalletNum/lCurrDepalletNum out of range
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************
public function JudgeCurWorkPiece (byval TotalArrayIndex as long) as long
   dim lTempCnt as long
   dim lRet as long = -1
   dim i as long = 1
   '*************先判断是拆垛还是码垛,然后将当前码垛/拆垛工件数给临时变量lTempCnt***************************************
   lTempCnt=getCurrWorkpieceCnt(TotalArrayIndex)
   '*************根据当前码垛/拆垛工件数判断当前工件所在的排数**********************************************************
   if lTempCnt < TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt*TotalPltArray[TotalArrayIndex]->lAllRowCount then
      while i<= TotalPltArray[TotalArrayIndex]->lAllRowCount
        if lTempCnt<=(i*TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt)-1 then
           lRet=i
           lCalcWorkPieceNum=(lTempCnt-(i-1)*TotalPltArray[TotalArrayIndex]->lAllWorkpieceCnt)+1 '保证计算时工件数不会大于每排的工件数
           goto EndJudgeCurWorkPiece
       else
         i=i+1
       end if
       sleep 10
     end while
   else
      lRet=-1
	  print "The current Workpiece number is invalid! "
   end if
   EndJudgeCurWorkPiece:
     JudgeCurWorkPiece=lRet
end function

'***********************************************************************************************************************
' function Name: JudgeCurWorkPiece
' Description: 根据当前码垛/拆垛工件数判断当前工件所在的排数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: long
'                    except 0 and -1-success
'                    -1-Failed or lCurrPalletNum/lCurrDepalletNum out of range
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public sub JudgeLimit(byval TotalArrayIndex as long,byval glCurrent as generic location)
  try 
	if glCurrent{1}> xmin and glCurrent{1}< xmax then
	 if glCurrent{2}> ymin and glCurrent{2}< ymax then
	   if glCurrent{3}> zmin and glCurrent{3}< zmax then
		   print "The target point is reachable:"glCurrent
	   else
		   print "The target point Z coordinate beyond Zmax limit or Zmin limit:"glCurrent
	   end if
	 else
		 print "The target point Y coordinate beyond Ymax limit or Ymin limit:"glCurrent      
	 end if
	else
		 print "The target point X coordinate beyond Xmax limit or Xmin limit:"glCurrent
	end if
   catch 3117
	print "The target point is not reachable"glCurrent
   catch 3121
	print "The target point is not reachable"glCurrent
   end try 
end sub 

'***********************************************************************************************************************
' sub Name: PworldToPwp
' Description: 将结构体里面的所有点位数据从通用坐标系下全部转换为标定workpiece坐标系下
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    SubIndex-排数索引，从1开始，上限值为5
' Output Parameters: None
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public sub PworldToPwp (byval TotalArrayIndex as long,byval SubIndex as long)
  dim glTempBase as generic location                 '基坐标系临时变量
  dim glTempMachineTable as generic location         '工作台坐标系临时变量
  dim glTempworkpiece as generic location            '工件坐标系临时变量
  dim glTempTool as generic location                 '工具坐标系临时变量
  dim glTemPoint as generic location                 '坐标变换临时点位变量
  dim glTempCalibratedFrame  as generic location     '标定的工件坐标系临时变量
  
  '*****************************先把示教得到的点位转化为通用坐标系（WorldFrame）下**************************************
  '****************************************获取当前各坐标系参数*********************************************************
  glTempBase=TotalPltArray[TotalArrayIndex]->glOriginalBase
  glTempMachineTable=TotalPltArray[TotalArrayIndex]->glOriginalMachineTable
  glTempworkpiece=TotalPltArray[TotalArrayIndex]->glOriginalworkpiece
  glTempTool=TotalPltArray[TotalArrayIndex]->glOriginaltool

  '*************************************排索引为SubIndex的起始点转为通用坐标系下的点************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glStartPoint[SubIndex]
  TotalPltArray[TotalArrayIndex]-> glStartPoint[SubIndex]=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool)
  
  '****************************************排索引为SubIndex的终止点转为通用坐标系下的点*********************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glTermPoint[SubIndex]
  TotalPltArray[TotalArrayIndex]-> glTermPoint[SubIndex]=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool)  
  
  '*********************************************单组路径参考点转为通用坐标系下的点**************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glSinRefPoint
  TotalPltArray[TotalArrayIndex]-> glSinRefPoint=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool) 
  
  '*********************************************单组路径趋近点转为通用坐标系下的点**************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glSinApproachPoint
  TotalPltArray[TotalArrayIndex]-> glSinApproachPoint=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool)

  '*********************************************单组路径回退点转为通用坐标系下的点**************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glSinBackPoint
  TotalPltArray[TotalArrayIndex]-> glSinBackPoint=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool)

  '*********************************************双组路径参考点转为通用坐标系下的点**************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouRefPoint
  TotalPltArray[TotalArrayIndex]-> glDouRefPoint=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool) 
 
  '*********************************************双组路径趋近点1转为通用坐标系下的点*************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[1]
  TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[1]=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool)  
 
  '*********************************************双组路径趋近点2转为通用坐标系下的点*************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[2]
  TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[2]=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool)   
 
  '*********************************************双组路径回退点1转为通用坐标系下的点*************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouBackPoint[1]
  TotalPltArray[TotalArrayIndex]-> glDouBackPoint[1]=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool)  
 
  '*********************************************双组路径回退点2转为通用坐标系下的点*************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouBackPoint[2]
  TotalPltArray[TotalArrayIndex]-> glDouBackPoint[2]=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool)  

  '*********************************************龙门跳路径参考点转为通用坐标系下的点************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glLmJumpRefPoint
  TotalPltArray[TotalArrayIndex]-> glLmJumpRefPoint=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool)  
 
  '*********************************************龙门跳路径过渡点转为通用坐标系下的点************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glLmJumpTransPoint
  TotalPltArray[TotalArrayIndex]-> glLmJumpTransPoint=Inverse(glTempBase):glTempMachineTable:glTempworkpiece:glTemPoint:Inverse(glTempTool)  
 
  '*****************************再将转换后的示教点点位转化为标定的工件坐标系（glCalibratedFrame）下*********************
  '****************************************获取标定后的坐标系参数*******************************************************
  
  glTempCalibratedFrame=TotalPltArray[TotalArrayIndex]->glCalibratedFrame[SubIndex]
  
  '****************************************排索引为SubIndex的起始点转为标定的工件坐标系下的点***************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glStartPoint[SubIndex]
  TotalPltArray[TotalArrayIndex]-> glStartPoint[SubIndex]=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool

  '****************************************排索引为SubIndex的终止点转为标定的工件坐标系下的点***************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glTermPoint[SubIndex]
  TotalPltArray[TotalArrayIndex]-> glTermPoint[SubIndex]=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool  
  
  '*******************************************单组路径参考点转为标定的工件坐标系下的点**********************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glSinRefPoint
  TotalPltArray[TotalArrayIndex]-> glSinRefPoint=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool  

  '*******************************************单组路径趋近点转为标定的工件坐标系下的点**********************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glSinApproachPoint
  TotalPltArray[TotalArrayIndex]-> glSinApproachPoint=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool 

  '*******************************************单组路径回退点转为标定的工件坐标系下的点**********************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glSinBackPoint
  TotalPltArray[TotalArrayIndex]-> glSinBackPoint=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool 

  '*******************************************双组路径参考点转为标定的工件坐标系下的点**********************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouRefPoint
  TotalPltArray[TotalArrayIndex]-> glDouRefPoint=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool 
  
  '*******************************************双组路径趋近点1转为标定的工件坐标系下的点*********************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[1]
  TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[1]=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool   

  '*******************************************双组路径趋近点2转为标定的工件坐标系下的点*********************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[2]
  TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[2]=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool

  '*******************************************双组路径回退点1转为标定的工件坐标系下的点*********************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouBackPoint[1]
  TotalPltArray[TotalArrayIndex]-> glDouBackPoint[1]=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool   

  '*******************************************双组路径回退点2转为标定的工件坐标系下的点*********************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouBackPoint[2]
  TotalPltArray[TotalArrayIndex]-> glDouBackPoint[2]=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool  

  '*******************************************龙门跳路径参考点转为标定的工件坐标系下的点********************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glLmJumpRefPoint
  TotalPltArray[TotalArrayIndex]-> glLmJumpRefPoint=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool 

  '*******************************************龙门跳路径过渡点转为标定的工件坐标系下的点********************************  
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glLmJumpTransPoint
  TotalPltArray[TotalArrayIndex]-> glLmJumpTransPoint=Inverse(glTempCalibratedFrame):Inverse(glTempMachineTable):glTempBase:glTemPoint:glTempTool   
end sub

'***********************************************************************************************************************
' sub Name: PwpToPworld
' Description: 将结构体里面的所有点位数据从标定的workpiece坐标系下全部转换为通用坐标系下
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalArrayIndex-通道数索引，从1开始，上限值为6
'                    SubIndex-排数索引，从1开始，上限值为5
' Output Parameters: None
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public sub PwpToPworld (byval TotalArrayIndex as long,byval SubIndex as long)

  dim glTempBase as generic location              '基坐标系临时变量
  dim glTempMachineTable as generic location      '工作台坐标系临时变量

  dim glTempTool as generic location              '工具坐标系临时变量
  dim glTemPoint as generic location              '坐标变换临时点位变量
  dim glTempCalibratedFrame as generic location   '标定的工件坐标系临时变量
  
  '*****************************将在标定的工件坐标系下点位转换为通用坐标系（WorldFrame）下******************************
  '****************************************获取当前各坐标系参数*********************************************************
  glTempBase=TotalPltArray[TotalArrayIndex]->glOriginalBase
  glTempMachineTable=TotalPltArray[TotalArrayIndex]->glOriginalMachineTable
  glTempTool=TotalPltArray[TotalArrayIndex]->glOriginaltool
  
  '***************************************标定的工件坐标系**************************************************************
  glTempCalibratedFrame=TotalPltArray[TotalArrayIndex]->glCalibratedFrame[SubIndex]
  
  '*************************************排索引为SubIndex的起始点转为通用坐标系下的点************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glStartPoint[SubIndex]
  TotalPltArray[TotalArrayIndex]-> glStartPoint[SubIndex]=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool)
  
  '****************************************排索引为SubIndex的终止点转为通用坐标系下的点*********************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glTermPoint[SubIndex]
  TotalPltArray[TotalArrayIndex]-> glTermPoint[SubIndex]=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool)  
  
  '*********************************************单组路径参考点转为通用坐标系下的点**************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glSinRefPoint
  TotalPltArray[TotalArrayIndex]-> glSinRefPoint=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool) 
  
  '*********************************************单组路径趋近点转为通用坐标系下的点**************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glSinApproachPoint
  TotalPltArray[TotalArrayIndex]-> glSinApproachPoint=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool)

  '*********************************************单组路径回退点转为通用坐标系下的点**************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glSinBackPoint
  TotalPltArray[TotalArrayIndex]-> glSinBackPoint=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool)

  '*********************************************双组路径参考点转为通用坐标系下的点**************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouRefPoint
  TotalPltArray[TotalArrayIndex]-> glDouRefPoint=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool) 
 
  '*********************************************双组路径趋近点1转为通用坐标系下的点*************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[1]
  TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[1]=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool)  
 
  '*********************************************双组路径趋近点2转为通用坐标系下的点*************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[2]
  TotalPltArray[TotalArrayIndex]-> glDouApproachPoint[2]=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool)   
 
  '*********************************************双组路径回退点1转为通用坐标系下的点*************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouBackPoint[1]
  TotalPltArray[TotalArrayIndex]-> glDouBackPoint[1]=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool)  
 
  '*********************************************双组路径回退点2转为通用坐标系下的点*************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glDouBackPoint[2]
  TotalPltArray[TotalArrayIndex]-> glDouBackPoint[2]=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool)  

  '*********************************************龙门跳路径参考点转为通用坐标系下的点************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glLmJumpRefPoint
  TotalPltArray[TotalArrayIndex]-> glLmJumpRefPoint=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool)  
 
  '*********************************************龙门跳路径过渡点转为通用坐标系下的点************************************
  glTemPoint=TotalPltArray[TotalArrayIndex]-> glLmJumpTransPoint
  TotalPltArray[TotalArrayIndex]-> glLmJumpTransPoint=Inverse(glTempBase):glTempMachineTable:glTempCalibratedFrame:glTemPoint:Inverse(glTempTool) 

end sub

'***********************************************************************************************************************
' sub Name: VerPltPworldToPwp
' Description: 垂直码垛将结构体里面的所有点位数据从通用坐标系下全部转换为glVerCalibratedFrame坐标系下
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: None
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public sub VerPltPworldToPwp (byval TotalVerArrayIndex as long)
  dim glVerTempBase as generic location                  '基坐标系临时变量
  dim glVerTempMachineTable as generic location          '工作台坐标系临时变量
  dim glVerTempworkpiece as generic location             '工件坐标系临时变量
  dim glVerTempTool as generic location                  '工具坐标系临时变量
  dim glVerTemPoint as generic location                  '坐标变换临时点位变量
  dim glVerTempCalibratedFrame  as generic location      '标定的工件坐标系临时变量
  
  '*****************************先把示教得到的点位转化为通用坐标系（WorldFrame）下**************************************
  '****************************************获取当前各坐标系参数*********************************************************
  glVerTempBase=TotalVerPltArray[TotalVerArrayIndex]->glVerOriginalbase
  glVerTempMachineTable=TotalVerPltArray[TotalVerArrayIndex]->glVerOriginalMachineTable
  glVerTempworkpiece=TotalVerPltArray[TotalVerArrayIndex]->glVerOriginalworkpiece
  glVerTempTool=TotalVerPltArray[TotalVerArrayIndex]->glVerOriginalTool
  
  '*********************************************垂直码垛参考点1转为通用坐标系下的点*************************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointOne
  TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointOne=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempworkpiece:glVerTemPoint:Inverse(glVerTempTool)

  '*********************************************垂直码垛参考点2转为通用坐标系下的点*************************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointTwo
  TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointTwo=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempworkpiece:glVerTemPoint:Inverse(glVerTempTool) 

  '*********************************************垂直码垛参考点3转为通用坐标系下的点*************************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointThree
  TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointThree=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempworkpiece:glVerTemPoint:Inverse(glVerTempTool)    

  '*********************************************垂直码垛单组路径参考点转为通用坐标系下的点******************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerSinRefPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerSinRefPoint=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempworkpiece:glVerTemPoint:Inverse(glVerTempTool)  

  '*********************************************垂直码垛单组路径趋近点转为通用坐标系下的点******************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerSinApproachPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerSinApproachPoint=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempworkpiece:glVerTemPoint:Inverse(glVerTempTool)  
  
  '*********************************************垂直码垛单组路径回退点转为通用坐标系下的点******************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerSinBackPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerSinBackPoint=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempworkpiece:glVerTemPoint:Inverse(glVerTempTool)    
  
  '*********************************************垂直码垛双组路径参考点转为通用坐标系下的点******************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouRefPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouRefPoint=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempworkpiece:glVerTemPoint:Inverse(glVerTempTool)  

  '*********************************************垂直码垛双组路径趋近点1转为通用坐标系下的点*****************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[1]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[1]=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempworkpiece:glVerTemPoint:Inverse(glVerTempTool)     
  
  '*********************************************垂直码垛双组路径趋近点2转为通用坐标系下的点*****************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[2]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[2]=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempworkpiece:glVerTemPoint:Inverse(glVerTempTool)   

  '*********************************************垂直码垛双组路径回退点1转为通用坐标系下的点*****************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[1]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[1]=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempworkpiece:glVerTemPoint:Inverse(glVerTempTool)     
  
  '*********************************************垂直码垛双组路径回退点2转为通用坐标系下的点*****************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[2]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[2]=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempworkpiece:glVerTemPoint:Inverse(glVerTempTool)    
  
  '*****************************再将转换后的示教点点位转化为标定的工件坐标系（glVerCalibratedFrame）下******************
  '****************************************获取标定后的坐标系参数*******************************************************  
  glVerTempCalibratedFrame=TotalVerPltArray[TotalVerArrayIndex]->glVerCalibratedFrame
  
  '*******************************************垂直码垛参考点1转为标定的工件坐标系下的点*********************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointOne
  TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointOne=Inverse(glVerTempCalibratedFrame):Inverse(glVerTempMachineTable):glVerTempBase:glVerTemPoint:glVerTempTool
  
  '*******************************************垂直码垛参考点2转为标定的工件坐标系下的点*********************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointTwo
  TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointTwo=Inverse(glVerTempCalibratedFrame):Inverse(glVerTempMachineTable):glVerTempBase:glVerTemPoint:glVerTempTool  
  
  '*******************************************垂直码垛参考点3转为标定的工件坐标系下的点*********************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointThree
  TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointThree=Inverse(glVerTempCalibratedFrame):Inverse(glVerTempMachineTable):glVerTempBase:glVerTemPoint:glVerTempTool    
  
  '*******************************************垂直码垛单组路径参考点转为标定的工件坐标系下的点**************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerSinRefPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerSinRefPoint=Inverse(glVerTempCalibratedFrame):Inverse(glVerTempMachineTable):glVerTempBase:glVerTemPoint:glVerTempTool    
  
  '*******************************************垂直码垛单组路径趋近点转为标定的工件坐标系下的点**************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerSinApproachPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerSinApproachPoint=Inverse(glVerTempCalibratedFrame):Inverse(glVerTempMachineTable):glVerTempBase:glVerTemPoint:glVerTempTool   
  
  '*******************************************垂直码垛单组路径回退点转为标定的工件坐标系下的点**************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerSinBackPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerSinBackPoint=Inverse(glVerTempCalibratedFrame):Inverse(glVerTempMachineTable):glVerTempBase:glVerTemPoint:glVerTempTool 

  '*******************************************垂直码垛双组路径参考点转为标定的工件坐标系下的点**************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouRefPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouRefPoint=Inverse(glVerTempCalibratedFrame):Inverse(glVerTempMachineTable):glVerTempBase:glVerTemPoint:glVerTempTool 

  '*******************************************垂直码垛双组路径趋近点1转为标定的工件坐标系下的点*************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[1]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[1]=Inverse(glVerTempCalibratedFrame):Inverse(glVerTempMachineTable):glVerTempBase:glVerTemPoint:glVerTempTool 

  '*******************************************垂直码垛双组路径趋近点2转为标定的工件坐标系下的点*************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[2]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[2]=Inverse(glVerTempCalibratedFrame):Inverse(glVerTempMachineTable):glVerTempBase:glVerTemPoint:glVerTempTool   

  '*******************************************垂直码垛双组路径回退点1转为标定的工件坐标系下的点*************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[1]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[1]=Inverse(glVerTempCalibratedFrame):Inverse(glVerTempMachineTable):glVerTempBase:glVerTemPoint:glVerTempTool 

  '*******************************************垂直码垛双组路径回退点2转为标定的工件坐标系下的点*************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[2]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[2]=Inverse(glVerTempCalibratedFrame):Inverse(glVerTempMachineTable):glVerTempBase:glVerTemPoint:glVerTempTool
  
end sub

'***********************************************************************************************************************
' sub Name: VerPltPwpToPworld
' Description: 垂直码垛将结构体里面的所有点位数据从glVerCalibratedFrame坐标系下全部转换为通用坐标系下
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道数索引，从1开始，上限值为6
' Output Parameters: None
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public sub VerPltPwpToPworld (byval TotalVerArrayIndex as long)
  dim glVerTempBase as generic location                  '基坐标系临时变量
  dim glVerTempMachineTable as generic location          '工作台坐标系临时变量

  dim glVerTempTool as generic location                  '工具坐标系临时变量
  dim glVerTemPoint as generic location                  '坐标变换临时点位变量
  dim glVerTempCalibratedFrame  as generic location      '标定的工件坐标系临时变量
  
  '*******************************把示教得到的点位转化为通用坐标系（WorldFrame）下**************************************
  '****************************************获取当前各坐标系参数*********************************************************
  glVerTempBase=TotalVerPltArray[TotalVerArrayIndex]->glVerOriginalbase
  glVerTempMachineTable=TotalVerPltArray[TotalVerArrayIndex]->glVerOriginalMachineTable

  glVerTempTool=TotalVerPltArray[TotalVerArrayIndex]->glVerOriginalTool
  
  '****************************************标定的工件坐标系参数*********************************************************
  glVerTempCalibratedFrame=TotalVerPltArray[TotalVerArrayIndex]->glVerCalibratedFrame
  
  '*********************************************垂直码垛参考点1转为通用坐标系下的点*************************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointOne
  TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointOne=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempCalibratedFrame:glVerTemPoint:Inverse(glVerTempTool)

  '*********************************************垂直码垛参考点2转为通用坐标系下的点*************************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointTwo
  TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointTwo=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempCalibratedFrame:glVerTemPoint:Inverse(glVerTempTool) 

  '*********************************************垂直码垛参考点3转为通用坐标系下的点*************************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointThree
  TotalVerPltArray[TotalVerArrayIndex]-> glVerRefPointThree=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempCalibratedFrame:glVerTemPoint:Inverse(glVerTempTool)    

  '*********************************************垂直码垛单组路径参考点转为通用坐标系下的点******************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerSinRefPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerSinRefPoint=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempCalibratedFrame:glVerTemPoint:Inverse(glVerTempTool)  

  '*********************************************垂直码垛单组路径趋近点转为通用坐标系下的点******************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerSinApproachPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerSinApproachPoint=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempCalibratedFrame:glVerTemPoint:Inverse(glVerTempTool)  
  
  '*********************************************垂直码垛单组路径回退点转为通用坐标系下的点******************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerSinBackPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerSinBackPoint=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempCalibratedFrame:glVerTemPoint:Inverse(glVerTempTool)    
  
  '*********************************************垂直码垛双组路径参考点转为通用坐标系下的点******************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouRefPoint
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouRefPoint=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempCalibratedFrame:glVerTemPoint:Inverse(glVerTempTool)  

  '*********************************************垂直码垛双组路径趋近点1转为通用坐标系下的点*****************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[1]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[1]=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempCalibratedFrame:glVerTemPoint:Inverse(glVerTempTool)     
  
  '*********************************************垂直码垛双组路径趋近点2转为通用坐标系下的点*****************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[2]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouApproachPoint[2]=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempCalibratedFrame:glVerTemPoint:Inverse(glVerTempTool)   

  '*********************************************垂直码垛双组路径回退点1转为通用坐标系下的点*****************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[1]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[1]=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempCalibratedFrame:glVerTemPoint:Inverse(glVerTempTool)     
  
  '*********************************************垂直码垛双组路径回退点2转为通用坐标系下的点*****************************
  glVerTemPoint=TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[2]
  TotalVerPltArray[TotalVerArrayIndex]-> glVerDouBackPoint[2]=Inverse(glVerTempBase):glVerTempMachineTable:glVerTempCalibratedFrame:glVerTemPoint:Inverse(glVerTempTool)
end sub

'***********************************************************************************************************************
' sub Name: setWorkpiece
' Description: 程序卸载后还原成默认的workpiece
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  None
' Output Parameters: None
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public sub setWorkpiece
  dim sRet as string
  dim sVESRet as string
  dim sExecute as string="workpiece=glTempCoordinate"
  while lSetWorkpieceFlag
    sRet=getUserProgStatusString
    if sRet="null"then
	  sVESRet=VESExecute(sExecute)
	  lSetWorkpieceFlag=False
	end if
    sleep 1000
  end while
end sub

'***********************************************************************************************************************
' sub Name: WorkpieceNumPlus
' Description: 每个工件码垛/拆垛运动完成，当前工件数加1
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  PltTypeValue-码垛类别，1-水平码垛，2-垂直码垛
'                    IndexValue-通道索引，从1开始，上限值为6
'                    PltOrDeplt-码垛还是拆垛，1-码垛，2-拆垛
' Output Parameters: None
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public sub WorkpieceNumPlus(byval PltTypeValue as long, byval IndexValue as long, byval PltOrDeplt as long)
  select case PltTypeValue
    '******************************水平码垛当前工件数增加***************************************************************
    case 1  
	   select case PltOrDeplt
	     case 1  '********************水平码垛当前码垛工件数增加********************************************************    
			 print "lCurrPalletNum:"TotalPltArray[IndexValue]->lCurrPalletNum
			 '*************码垛运动完成，当前码垛工件数加1************************************************************** 
			 TotalPltArray[IndexValue]->lCurrPalletNum=(TotalPltArray[IndexValue]->lCurrPalletNum)+1
			 
			 ?saveNewPltData
			 
			 '*************当前码垛工件数如果等于该排总工件数，重新置为0************************************************			 
			 if (TotalPltArray[IndexValue]->lCurrPalletNum= \
			 TotalPltArray[IndexValue]->lAllWorkpieceCnt*TotalPltArray[IndexValue]->lAllRowCount) then      
			   TotalPltArray[IndexValue]->lCurrPalletNum =0
			 end if 			 
			 
			 
	     case 2  '********************水平码垛当前拆垛工件数增加********************************************************
             print "lCurrDepalletNum:"TotalPltArray[IndexValue]->lCurrDepalletNum		 
             '*************拆垛运动完成，当前拆垛工件数加1************************************************************** 
             TotalPltArray[IndexValue]->lCurrDepalletNum=(TotalPltArray[IndexValue]->lCurrDepalletNum)+1
			 
			 ?saveNewPltData
			 
			 '*************当前拆垛工件数如果等于该排总工件数，重新置为0************************************************
             if (TotalPltArray[IndexValue]->lCurrDepalletNum= \
             TotalPltArray[IndexValue]->lAllWorkpieceCnt*TotalPltArray[IndexValue]->lAllRowCount) then
               TotalPltArray[IndexValue]->lCurrDepalletNum =0
             end if 		 
	   end select
	   
    '******************************垂直码垛当前工件数增加***************************************************************	   
    case 2
	   select case PltOrDeplt
	     case 1  '********************垂直码垛当前码垛工件数增加********************************************************
     
             print "lVerCurrPalletNum:"TotalVerPltArray[IndexValue]->lVerCurrPalletNum			 
             '*************码垛运动完成，当前码垛工件数加1************************************************************** 
             TotalVerPltArray[IndexValue]->lVerCurrPalletNum=(TotalVerPltArray[IndexValue]->lVerCurrPalletNum)+1
			 
			 ?saveNewVerPltData
			 
             '*************当前码垛工件数如果等于该排总工件数，重新置为0************************************************
             if (TotalVerPltArray[IndexValue]->lVerCurrPalletNum= \
             lCalcColumnCount*lCalcRowCount*TotalVerPltArray[IndexValue]->lVerNumofPlies) then
               TotalVerPltArray[IndexValue]->lVerCurrPalletNum =0
             end if 
	     case 2  '********************垂直码垛当前拆垛工件数增加********************************************************
             print "lVerCurrDepalletNum:"TotalVerPltArray[IndexValue]->lVerCurrDepalletNum		 			 
             '*************拆垛运动完成，当前拆垛工件数加1************************************************************** 
             TotalVerPltArray[IndexValue]->lVerCurrDepalletNum=(TotalVerPltArray[IndexValue]->lVerCurrDepalletNum)+1
			 
			 ?saveNewVerPltData
			 
             '*************当前拆垛工件数如果等于该排总工件数，重新置为0************************************************
             if (TotalVerPltArray[IndexValue]->lVerCurrDepalletNum= \
             lCalcColumnCount*lCalcRowCount*TotalVerPltArray[IndexValue]->lVerNumofPlies) then
               TotalVerPltArray[IndexValue]->lVerCurrDepalletNum =0
             end if 
	   end select	
  end select 
end sub

'***********************************************************************************************************************
' sub Name: PalletDone
' Description: 水平和垂直码垛/拆垛层垛、堆垛完成提示
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  PltTypeValue-码垛类别，1-水平码垛，2-垂直码垛
'                    IndexValue-通道索引，从1开始，上限值为6
' Output Parameters: long
'                    0-当前码垛/拆垛正在进行
'                    1-水平码垛/拆垛堆垛完成提示,垂直码垛/拆垛为层垛完成提示
'                    2- 垂直码垛/拆垛堆垛完成提示
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function PalletDone (ByVal PltTypeValue as long,byval IndexValue as long ) as long
  dim i as long=1
  dim lRet as long
  dim lTempCnt as long
  
  select case PltTypeValue
    case 1  '*****************************水平码垛堆码垛完成判断********************************************************
	   if TotalPltArray[IndexValue]->lStackType = 1 then
	      lTempCnt=TotalPltArray[IndexValue]->lCurrPalletNum
	      if lTempCnt = 0 then
		    lRet=1
			goto endPalletDone
		  else
		    lRet=0
			goto endPalletDone
		  end if
	   end if
	   if TotalPltArray[IndexValue]->lStackType = 2 then
	      lTempCnt=TotalPltArray[IndexValue]->lCurrDepalletNum
	      if lTempCnt = 0 then
		    lRet=1
			goto endPalletDone
		  else
		    lRet=0	
			goto endPalletDone
		  end if
	   end if	   
    case 2  '*************************垂直码垛层码垛、堆码垛完成判断****************************************************
	   if TotalVerPltArray[IndexValue]->lVerStackType = 1 then
	      lTempCnt=TotalVerPltArray[IndexValue]->lVerCurrPalletNum
		  
		  '*************垂直码垛层先判断当前码垛工件数是否为层码垛工件数的要求，若达到返回1，否则进行堆码垛数判断*******
		  while i <= (TotalVerPltArray[IndexValue]->lVerNumofPlies-1)
		    if lTempCnt = i*lCalcColumnCount*lCalcRowCount then
			   lRet=1
			   goto endPalletDone
		    else 
			   i=i+1
		    end if
			sleep 5
		  end while
		  '*************垂直码垛层先判断当前码垛工件数是否为堆码垛工件数的要求，若达到返回2，否则返回0，跳出判断*******
		  if lTempCnt = 0  then
		    lRet=2
			goto endPalletDone
          else
		    lRet=0
			goto endPalletDone
          end if		  
	   end if
	     
	   if TotalVerPltArray[IndexValue]->lVerStackType = 2 then
	      lTempCnt=TotalVerPltArray[IndexValue]->lVerCurrDepalletNum
		  '*************垂直码垛层先判断当前拆垛工件数是否为层拆垛工件数的要求，若达到返回1，否则进行堆拆垛数判断*******
		  while i <= (TotalVerPltArray[IndexValue]->lVerNumofPlies-1)
		    if lTempCnt = i*lCalcColumnCount*lCalcRowCount then
			   lRet=1
			   goto endPalletDone
		    else 
			   i=i+1
		    end if
			sleep 5
		  end while
		  if lTempCnt = 0  then
		    lRet=2
			goto endPalletDone
          else
		    lRet=0
			goto endPalletDone
          end if
	   end if	   
  end select
  endPalletDone:
  PalletDone=lRet
end function

'***********************************************************************************************************************
' sub Name: CalcVerWorkPieceCnt
' Description: 垂直码垛/拆垛根据参考点计算工件行数、列数和总工件数
' Called From:  teach pendant
' Author: Demean
' Input Parameters:  long
'                    TotalVerArrayIndex-通道索引，从1开始，上限值为6
' Output Parameters: string
'                    sRowCnt-字符串类型行数
'                    sColumuCnt-字符串类型列数
'                    sVerAllWPCnt- 字符串类型总工件数
' Return Value: 
' Algorithm: 
' Global Variables Used: 
' Revisions:
'***********************************************************************************************************************

public function CalcVerWorkPieceCnt (byval TotalVerArrayIndex as long)as string
  dim sRowCnt as string
  dim sColumuCnt as string
  dim sVerAllWPCnt as string
  dim sCommo as string=","
  dim XSpacing as double
  dim YSpacing as double
  dim ZSpacing as double
  dim dDistance as double
  dim dtemp as double
  dim lCalcColumnCount as long
  dim lCalcRowCount as long
  
    '*****************根据参考点1和2、列间距、工件长度计算垂直码垛每层工件的列数***************************************
   XSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointTwo{1}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{1}
   YSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointTwo{2}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{2}
   ZSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointTwo{3}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{3}
   
   dDistance=sqrt(XSpacing^2+YSpacing^2+ZSpacing^2)
   
   dTemp=dDistance/(TotalVerPltArray[TotalVerArrayIndex]->llengthofWorkpiece+TotalVerPltArray[TotalVerArrayIndex]->lColumnSpacing)+1
   '列数取整
   lCalcColumnCount=int(dTemp)
   sColumuCnt=str$(lCalcColumnCount)
   
   '*****************根据参考点1和3、行间距、工件宽度计算垂直码垛每层工件的行数****************************************
   XSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointThree{1}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{1}
   YSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointThree{2}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{2}
   ZSpacing=TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointThree{3}-TotalVerPltArray[TotalVerArrayIndex]->glVerRefPointOne{3}
   
   dDistance=sqrt(XSpacing^2+YSpacing^2+ZSpacing^2)
   
   dTemp=dDistance/(TotalVerPltArray[TotalVerArrayIndex]->lwidthofWorkpiece+TotalVerPltArray[TotalVerArrayIndex]->lRowSpacing)+1
   '行数取整
   lCalcRowCount=int(dTemp)
   sRowCnt=str$(lCalcRowCount)
   
   lVerPltAllWPCount[TotalVerArrayIndex]=lCalcRowCount*lCalcColumnCount*TotalVerPltArray[TotalVerArrayIndex]->lVerNumofPlies
   sVerAllWPCnt= str$(lVerPltAllWPCount[TotalVerArrayIndex])
   ?saveNewVerPltData
   
   CalcVerWorkPieceCnt = sRowCnt+sCommo+sColumuCnt+sCommo+sVerAllWPCnt
end function